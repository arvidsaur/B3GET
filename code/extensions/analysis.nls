; ========================================================================================================= ;
; 
;                                                                                    
;   .d888888  888888ba   .d888888  dP        dP    dP .d88888b  dP .d88888b  
;  d8'    88  88    `8b d8'    88  88        Y8.  .8P 88.    "' 88 88.    "' 
;  88aaaaa88a 88     88 88aaaaa88a 88         Y8aa8P  `Y88888b. 88 `Y88888b. 
;  88     88  88     88 88     88  88           88          `8b 88       `8b 
;  88     88  88     88 88     88  88           88    d8'   .8P 88 d8'   .8P 
;  88     88  dP     dP 88     88  88888888P    dP     Y88888P  dP  Y88888P  
;                                                                          
;            
; Â© 2021 K N Crouse  
; ========================================================================================================= ;

to thesis-setup
  
  clear-all                                                    ; Delete all current settings in the simulation.
  reset-ticks                                                  ; Reset the timesteps to zero.
  
  set path-to-experiment "../results/thesis/"
  set genotype-reader "sta2us"
  set output-results? true 
  set selection-on? false
  set plant-annual-cycle 1000
  set plant-daily-cycle 10
  set plant-seasonality 0.5
  set plant-quality 4
  set deterioration-rate -0.01
  
  set maximum-population-size 200
  set minimum-population-size 200
  
  ; final settings 
  set simulation-summary-ticks 25000 
  set simulation-scan-ticks 250 
  set group-scan-ticks 2000 
  set individual-scan-ticks 0 
  set view-scan-ticks 10000 
  set genotype-scan-ticks 10000
  set focal-follow-rate 1E-4
  set record-individuals true 
  set verification-rate 1E-5
  set record-world-ticks 100000
  set simulation-stop-at 200
  
;  set simulation-summary-ticks 500 
;  set simulation-scan-ticks 250 
;  set group-scan-ticks 100
;  set individual-scan-ticks 0 
;  set view-scan-ticks 100
;  set genotype-scan-ticks 100
;  set focal-follow-rate 1E-3 
;  set record-individuals true 
;  set verification-rate 1E-5
;  set record-world-ticks 1000
;  set simulation-stop-at 200
  
  if ( model-structure = 0 ) [ set model-structure [] ]
  
  ( ifelse
    ( first behaviorspace-experiment-name = "A" ) [  ]
    ( first behaviorspace-experiment-name = "B" ) [ set plant-annual-cycle 10000 set plant-daily-cycle 100 ]
    ( first behaviorspace-experiment-name = "C" ) [ set plant-annual-cycle 10000 ]
    ( first behaviorspace-experiment-name = "D" ) [ set plant-daily-cycle 100 ]
    ( first behaviorspace-experiment-name = "E" ) [ set plant-seasonality 0 ]
    ( first behaviorspace-experiment-name = "F" ) [ set plant-seasonality 1 ]
    ( first behaviorspace-experiment-name = "G" ) [ set plant-quality 2 ]
    ( first behaviorspace-experiment-name = "H" ) [ set plant-quality 6 ]
    ( first behaviorspace-experiment-name = "I" ) [ set deterioration-rate -0.001 ]
    ( first behaviorspace-experiment-name = "J" ) [ set model-structure lput "aspatial" model-structure ]
    ( first behaviorspace-experiment-name = "K" ) [ set model-structure lput "stork" model-structure ]
    ( first behaviorspace-experiment-name = "L" ) [ set model-structure lput "reaper" model-structure ]
    ( first behaviorspace-experiment-name = "M" ) [ 
      set model-structure lput "ideal-form" model-structure set model-structure lput "stork" model-structure ]
    ( first behaviorspace-experiment-name = "N" ) [ set model-structure lput "free-lunch" model-structure ]
    ( first behaviorspace-experiment-name = "O" ) [ set model-structure lput "no-evolution" model-structure ]
    ( first behaviorspace-experiment-name = "P" ) [ set model-structure lput "uninvadable" model-structure ]
    [  ] )
  
  ;setup-nine-runs
  setup-four-runs

  setup-parameters                                             ; Setup the global parameter settings.
  setup-patches                                                ; Initialize the plants for a new simulation.
  import-population                                            ; Create an initial population of indiviudals
  import-genotype                                              ; and their genotypes from user files.
  
  output-print (word                                           ; Once setup is complete, display the current
    " Simulation " simulation-id " "                           ; state of the new simulation.
    behaviorspace-run-number " end setup at "
    date-and-time )
  
end

to thesis-final
  simulation-summary
  if ( record-individuals ) [ ask anima1s with [ is.alive ] [ individual-summary ]]
end

to setup-four-runs
  
  if ( length behaviorspace-experiment-name = 4 ) [
    
    set plant-minimum-neighbors read-from-string ( item 1 behaviorspace-experiment-name )
    set plant-maximum-neighbors read-from-string ( item 2 behaviorspace-experiment-name )
    
    ( ifelse 
      ( population = "Chimpanzees" ) [
        set genotype "chimpanzees" ]
      ( population = "Geladas")[
        set genotype "geladas" ]
      ( population = "Hamadryas" )[
        set genotype "hamadryas" ]
      ( population = "Olives" )[
        set genotype "olives" ]
      [])
    
    set simulation-id ( word "s" 
      first behaviorspace-experiment-name 
      first population
      plant-minimum-neighbors 
      plant-maximum-neighbors 
      item 3 behaviorspace-experiment-name )]
  
end

to setup-nine-runs
  
  set plant-maximum-neighbors read-from-string last behaviorspace-experiment-name
  
  ( ifelse 
    ( item 1 behaviorspace-experiment-name = "C" ) [
      set population "Chimpanzees"
      set genotype "chimpanzees" ]
    ( item 1 behaviorspace-experiment-name = "G" )[
      set population "Geladas"
      set genotype "geladas" ]
    ( item 1 behaviorspace-experiment-name = "H" )[
      set population "Hamadryas"
      set genotype "hamadryas" ]
    ( item 1 behaviorspace-experiment-name = "O" )[
      set population "Olives"
      set genotype "olives" ]
    ( item 1 behaviorspace-experiment-name = "Q" ) [
      set population "Chimpanzees"
      set genotype "geladas" ]
    ( item 1 behaviorspace-experiment-name = "R" )[
      set population "Chimpanzees"
      set genotype "hamadryas" ]
    ( item 1 behaviorspace-experiment-name = "S" )[
      set population "Chimpanzees"
      set genotype "olives" ]
    ( item 1 behaviorspace-experiment-name = "T" )[
      set population "Geladas"
      set genotype "chimpanzees" ]
    ( item 1 behaviorspace-experiment-name = "U" ) [
      set population "Hamadryas"
      set genotype "chimpanzees" ]
    ( item 1 behaviorspace-experiment-name = "V" )[
      set population "Olives"
      set genotype "chimpanzees" ]
    [])
  
  ; give simulation-id specific configuration: sDO17B means
  ; simulation of WORLD-D, Baboons seed population,
  ; run B (instead of A), plant-minimum-neighbors = 1 and
  ; plant-maximum-neighbors = 7
  ifelse ( plant-minimum-neighbors < plant-maximum-neighbors ) [
    set simulation-id ( word "s" but-last behaviorspace-experiment-name plant-minimum-neighbors plant-maximum-neighbors "A" )
  ][
    let min-holder plant-minimum-neighbors
    let max-holder plant-maximum-neighbors
    set plant-minimum-neighbors max-holder - 1
    set plant-maximum-neighbors min-holder
    set simulation-id ( word "s" but-last behaviorspace-experiment-name plant-minimum-neighbors plant-maximum-neighbors "B" )
  ]
  
end

to set-results-settings
  
  set simulation-summary-ticks 10000     
  set simulation-scan-ticks 1000         
  set group-scan-ticks 1000                
  set individual-scan-ticks 0           
  set view-scan-ticks 1000                
  set genotype-scan-ticks 1000            
  set focal-follow-rate 1E-3               
  set record-individuals true            
  set verification-rate 1E-5             
  set record-world-ticks 0   
  
end

;reduce-to-unique-vectors                                     ; Reduce to unique set of decision vectors

; --------------------------------------------------------------------------------------------------------- ;
;
; HELPER SUBROUTINE TO REDUCE LIST OF DECISIONS TO UNIQUE COMBINATIONS OF TARGET AND ACTION
;
; This subroutine reduces the current list of decision vectors into a list of unique vectors such that
; there is only one vector for each combination of target and action. During this reduction processes, the
; decision vector weights are added together resulting in a decision vector with the net weight.
;
; ENTRY: Initial list of decision vectors before reduction process.
;
; EXIT:  Final list of decision vectors after the reduction process.
;
; --------------------------------------------------------------------------------------------------------- ;

to reduce-to-unique-vectors

  let initial-decisions decision.vectors                         ; Initially, there is a full list of decisions
  let reduced-decisions []                                       ; and an empty list.

  foreach initial-decisions [ original-vector ->                 ; Looping through the full list of decisions,
    let original-ego item 0 original-vector                      ; identify the caller,
    let original-target item 1 original-vector                   ; identity the target,
    let original-action item 2 original-vector                   ; identity the action,
    let original-weight item 3 original-vector                   ; identify the cost.

    let vector-doesnt-exist true                                 ;

    let index 0                                                  ;
    foreach reduced-decisions [ reduced-vector ->                ;
      let reduced-ego item 0 reduced-vector                      ;
      let reduced-target item 1 reduced-vector                   ;
      let reduced-action item 2 reduced-vector                   ;
      let reduced-weight item 3 reduced-vector                   ;

      if ( reduced-ego = original-ego )                          ;
      and ( reduced-target = original-target )                   ;
      and ( reduced-action = original-action ) [                 ;

        set vector-doesnt-exist false                            ;

        set reduced-weight ifelse-value                          ;
        ( is-number? reduced-weight )                            ;
        [ reduced-weight ]                                       ;
        [ 0 ]                                                    ;

        set original-weight ifelse-value                         ;
        ( is-number? original-weight )                           ;
        [ original-weight ]                                      ;
        [ 0 ]                                                    ;

        let new-vector ( list                                    ;
          self                                                   ;
          reduced-target                                         ;
          reduced-action                                         ;
          ( reduced-weight + original-weight )                   ;
          false )                                                ;

        set reduced-decisions                                    ;
        remove-item index reduced-decisions                      ;

        set reduced-decisions                                    ;
        lput new-vector reduced-decisions ]                      ;

      set index index + 1                                        ;
    ]

    if vector-doesnt-exist [                                     ;
      set reduced-decisions lput                                 ;
      ( list                                                     ;
        self                                                     ;
        original-target                                          ;
        original-action                                          ;
        original-weight                                          ;
        false )                                                  ;
      reduced-decisions ]                                        ;
  ]
  set decision.vectors reduced-decisions                         ;
end

to match-heading [ target cost ]
  complete-action target "match-heading" cost
;  ;print heading
;  ;print [heading] of target
  ;  let total-cost 10 * cost / ( abs deterioration-rate ) ; scaled with deterioration rate
  ;  let heading-difference subtract-headings heading [heading] of target
  ;  ;print heading-difference
  ;  let cost-of-heading abs heading-difference / 360
  ;  ;print cost-of-heading
  ;
  ;  ifelse ( total-cost >= cost-of-heading ) [
  ;    set heading [heading] of target
  ;  ][
  ;    set heading heading + 360 * total-cost * -1 * ( heading-difference / abs heading-difference )
  ;  ]
  ;print heading
  ;print ""


  if (target != nobody ) [

    ; deteremine x and y coordinate difference to target
    let ycor-difference [ y.magnitude ] of target
    let xcor-difference [ x.magnitude ] of target

    if ( not ( ycor-difference = 0 and xcor-difference = 0 ) ) [ ; If the target isn't in the exact same location as self

      ; calculate angle to target
      let angle atan xcor-difference ycor-difference
      if ( cost < 0 ) [ set angle angle - 180 ]

      ; set magnitudes based on cost
      set x.magnitude x.magnitude + (abs cost * sin angle)
      set y.magnitude y.magnitude + (abs cost * cos angle) ]

    ; set heading based on magnitudes
    set heading ifelse-value ( x.magnitude = 0 and y.magnitude = 0 ) [ heading ] [ ( atan x.magnitude y.magnitude ) ]
  ]

end


  
  ;-------------------------------------------------------------------------------------------------
  ; SPOT CHECK FUNCTIONS
  ;-------------------------------------------------------------------------------------------------
  
to reset-chromosomes
  ;  if ( mother != nobody and father != nobody ) [
  ;    ask mother [ 
  ;      set chromosome.I [ [ true "A" "B" "C" ] [ true "D" "E" "F" ] [ true "G" "H" "I" ] [ true "X" "Y" "Z" ] [ true "E" 0.1 0.2 0.3 ]] 
  ;      set chromosome.II [ [ true "A2" "B2" "C2" ] [ true "D2" "E2" "F2" ] [ true "G2" "H2" "I2" ] ] 
  ;    ]
  ;    ask father [ 
  ;      set chromosome.I [ [ true "J" "K" "L" ] [ true "M" "N" "O" ] [ true "P" "Q" "R" ] ] 
  ;      set chromosome.II [ [ true "J2" "K2" "L2" ] [ true "M2" "N2" "O2" ] [ true "P2" "Q2" "R2" ]  ] 
  ;    ]
  ;    setup-chromosomes-from mother father
  ;  ]
end

  
;--------------------------------------------------------------------------------------------------------------------
;
; PARAMETER SPACE SWEEPING FOR RSN BEST FIT
;
;--------------------------------------------------------------------------------------------------------------------

to-report calculate-lotka-volterra
  
  let N1a first plant-abundance-record
  let N2a first population-size-record
  
  let bestparam []
  let gmax 0
  
  let N1r1  500
  let N1r2  1500
  let N2r1  25
  let N2r2  45
  let r1r1   0.1
  let r1r2   0.9
  let r2r1  -0.9
  let r2r2  -0.1
  let s12r1 -0.1
  let s12r2 -0.001
  let s21r1 0.0001
  let s21r2 0.002
  let steps 10
  
  let N1w N1r1 - (N1r2 - N1r1) / steps
  while [ N1w < N1r2 + (N1r2 - N1r1) / steps / 2 ]
  [ Set N1w N1w + (N1r2 - N1r1) / steps
    
    let N2w N2r1 - (N2r2 - N2r1) / steps
    while [ N2w < N2r2 + (N2r2 - N2r1) / steps / 2 ]
    [ Set N2w N2w + (N2r2 - N2r1) / steps
      
      let r1w r1r1 - (r1r2 - r1r1) / steps
      while [ r1w < r1r2 + (r1r2 - r1r1) / steps / 2 ]
      [ Set r1w r1w + (r1r2 - r1r1) / steps
        
        let r2w r2r1 - (r2r2 - r2r1) / steps
        while [ r2w < r2r2 + (r2r2 - r2r1) / steps / 2 ]
        [ Set r2w r2w + (r2r2 - r2r1) / steps
          
          let s12w s12r1 - (s12r2 - s12r1) / steps
          while [ s12w < s12r2 + (s12r2 - s12r1)/ steps / 2 ]
          [ Set s12w s12w + (s12r2 - s12r1)/ steps
            
            let s21w s21r1 - (s21r2 - s21r1) / steps
            while [ s21w < s21r2 + (s21r2 - s21r1)/ steps / 2 ]
            [ Set s21w s21w + (s21r2 - s21r1)/ steps
              
              let results rsn r1w r2w 0 s12w s21w 0 N1w N2w ; Simulate the rsN equations.
              let N1s first results
              let N2s last  results
              
              let g1 fit N1a N1s                            ; Calculate goodness of fit for
              let g2 fit N2a N2s                            ; both curves.
              
              let g ( g1 + g2 ) / 2                            ; Report the results.
              if  ( g > gmax )
              [ set bestparam ( list g r1w r2w s12w s21w N1w N2w )
                set gmax g ]
              
  ] ] ] ] ] ]
  
  ;....display the best result....
  report bestparam
  
end

;--------------------------------------------------------------------------------------------------------------------
;
; SUBROUTINE TO SIMULATE RSN DIFFERENTIAL EQUATION
;
; This routine simulates two ecological populations growing according
; to the <m>rsN</m> equations,
;   <M> {1\over N_1}\,{dN_1\over dt} = r_1 +s_{1,1}N_1 +s_{1,2}N_2 </M>
;   <M> {1\over N_2}\,{dN_2\over dt} = r_2 +s_{2,1}N_1 +s_{2,2}N_2 </M>
;
; It uses the Euler method<https://en.wikipedia.org/wiki/Euler_method/> to solve
; the differential equations numerically. The time step <v>dt</v> should be made
; small enough so that further decreases in its value do not significantly change
; the solution.
;
; Any parameters may be supplied below to represent variations of competition,
; predation, mutualism, or other two-species interactions such as commensalism.
;
; ENTRY: 'r1'  and 'r2' contain the intrinsic growth rates for each species.
;        's11' and 's22' ('sii') contain the self-limitation or enhancement terms
;         for each species.
;        's12' and 's21' ('sij') contain the cross-coupling terms for species for
;          the limiting or enhancement of the growth of species 'i' by species 'j'.
;        'N1i' and 'N2i' contain the starting values for each species.
;
; EXIT:  'N1s' and 'N2s' contain the simulated results, yearly for 40 years.
;         (The ending time should be a parameter.)
;
;--------------------------------------------------------------------------------------------------------------------
  
to-report rsn [r1 r2 s11 s12 s21 s22 N1i N2i ]
  ;  let r1 1
  ;  let r2 1
  ;  let s11 -1 ; throw out?
  ;  let s12 -.5
  ;  let s21 1
  ;  let s22 -1 ; throw out?
  ;  let N1 0.4
  ;  let N2 0.1
  
  Let N1 N1i                                                        ; Set the initial conditions.
  Let N2 N2i
  
  Let dt 1 / 365                                                    ; Set the time step.
  
  Let N1s []                                                        ; Establish the output lists.
  Let N2s []
  
  let y -1                                                          ; Loop through all years.
  while [ y < 40 ]
  [
    Set y y + 1                                                     ; Add the present population values
    Set N1s lput N1 N1s                                             ; to the end of the respective lists.
    Set N2s lput N2 N2s
    
    let t ( 0 - dt )                                                ; Step day by day through the year,
    while [ t < ( 1 + dt / 2 ) ]                                    ; calculating but not recording
    [ Set t t + dt                                                  ; the intermediate results.
      Let dN1 ( r1 + s11 * N1 + s12 * N2 ) * N1 * dt
      Let dN2 ( r2 + s21 * N1 + s22 * N2 ) * N2 * dt
      Set N1 N1 + dN1
      Set N2 N2 + dN2
      if ( N1 < 0 ) [ Set N1 0 ]
      if ( N2 < 0 ) [ Set N2 0 ] ] ]
  
  report ( list N1s N2s )                                          ; Return the simulated results.
  
end

;--------------------------------------------------------------------------------------------------------------------
;
; SUBROUTINE TO CALCULATE GOODNESS OF FIT                  
;
; This routine accepts a set of data containing observations and predictions,
; and computes how well the predictions match the observations. Various
; measures of how well they match could be calculated in this routine, such as
; with least-squares, least absolute value, or other measures. The goodness of
; fit is presented in the form of
; <m>R^2</m>.<https://en.wikipedia.org/wiki/Coefficient_of_determination/>
;
; That is, it is presented as <m>1-F/E</m>, where
; <m>F</m> is the summed deviations of the observations from the predictions, and
; <m>E</m> is the summed deviations of the observations from the expected value
; (mean) of the observations, assuming there were no functional relationship.
;
; ENTRY: 'k' specifies the number of actual values there are.
;        'S' contains the estimated values from the simulated curve, indexed by
;         time, starting with time 0.
;        'A' contains the actual measured values, indexed arbitrarily from 1 to
;         'k'.
;        'y' defines the time index for each corresponding value in 'A', also
;         indexed arbitrarily from 1 to 'k'
;
; EXIT:  'g' contains the goodness of fit measure for that data.
;
;--------------------------------------------------------------------------------------------------------------------

to-report fit [ A S ]
  
  let mu mean A                                         ; Compute the mean of the data.
  
  let total 0                                           ; Prepare variables for loop.
  let residual 0
  let k length A
  let i 0
  
  while [ i < k ]
  [ set i i + 1                                         ; Compute the total squared
    Set residual residual + ( item i A - item i S ) ^ 2 ; deviations of the actual data
    Set total total + ( item i A - mu ) ^ 2             ; from the function and from the
  ]                                                     ; mean.
  
  report 1 - residual / total                           ; Return the goodness-of-fit.
  
end



; NOTE FOR CL: if     (..condition..) [..truepart..]
;              ifelse (..condition..) [..truepart..] [..falsepart..]


;    lotka-volterra-best-fit
;    lotka-volterra-r1
;    lotka-volterra-r2
;    lotka-volterra-s12
;    lotka-volterra-s21
;    lotka-volterra-N1
;    lotka-volterra-N2
;    
;    optimal-foraging-regression-constant
;    optimal-foraging-regression-coeff
;    optimal-foraging-r-squared
;    optimal-foraging-adj-r-squared
;    optimal-foraging-F-statistic
;    optimal-foraging-probability-of-F
;    optimal-foraging-standard-error
;    optimal-foraging-tot-degrees-of-freedom
;    optimal-foraging-reg-degrees-of-freedom
;    optimal-foraging-err-degrees-of-freedom
;    optimal-foraging-tot-sum-of-squares
;    optimal-foraging-reg-sum-of-squares
;    optimal-foraging-err-sum-of-squares
;    
;    mother-initiated-birth-regression-constant
;    mother-initiated-birth-regression-coeff
;    mother-initiated-birth-r-squared
;    mother-initiated-birth-adj-r-squared
;    mother-initiated-birth-F-statistic
;    mother-initiated-birth-probability-of-F
;    mother-initiated-birth-standard-error
;    mother-initiated-birth-tot-degrees-of-freedom
;    mother-initiated-birth-reg-degrees-of-freedom
;    mother-initiated-birth-err-degrees-of-freedom
;    mother-initiated-birth-tot-sum-of-squares
;    mother-initiated-birth-reg-sum-of-squares
;    mother-initiated-birth-err-sum-of-squares
;    
;    mother-initiated-wean-regression-constant
;    mother-initiated-wean-regression-coeff
;    mother-initiated-wean-r-squared
;    mother-initiated-wean-adj-r-squared
;    mother-initiated-wean-F-statistic
;    mother-initiated-wean-probability-of-F
;    mother-initiated-wean-standard-error
;    mother-initiated-wean-tot-degrees-of-freedom
;    mother-initiated-wean-reg-degrees-of-freedom
;    mother-initiated-wean-err-degrees-of-freedom
;    mother-initiated-wean-tot-sum-of-squares
;    mother-initiated-wean-reg-sum-of-squares
;    mother-initiated-wean-err-sum-of-squares
;    
;    hamiltons-rule-regression-constant
;    hamiltons-rule-regression-coeff
;    hamiltons-rule-r-squared
;    hamiltons-rule-adj-r-squared
;    hamiltons-rule-F-statistic
;    hamiltons-rule-probability-of-F
;    hamiltons-rule-standard-error
;    hamiltons-rule-tot-degrees-of-freedom
;    hamiltons-rule-reg-degrees-of-freedom
;    hamiltons-rule-err-degrees-of-freedom
;    hamiltons-rule-tot-sum-of-squares
;    hamiltons-rule-reg-sum-of-squares
;    hamiltons-rule-err-sum-of-squares
    
;      
;      "lotka-volterra-best-fit"
;      "lotka-volterra-r1"
;      "lotka-volterra-r2"
;      "lotka-volterra-s12"
;      "lotka-volterra-s21"
;      "lotka-volterra-N1"
;      "lotka-volterra-N2"
;      
;      "optimal-foraging-regression-constant"
;      "optimal-foraging-regression-coeff"
;      "optimal-foraging-r-squared"
;      "optimal-foraging-adj-r-squared"
;      "optimal-foraging-F-statistic"
;      "optimal-foraging-probability-of-F"
;      "optimal-foraging-standard-error"
;      "optimal-foraging-tot-degrees-of-freedom"
;      "optimal-foraging-reg-degrees-of-freedom"
;      "optimal-foraging-err-degrees-of-freedom"
;      "optimal-foraging-tot-sum-of-squares"
;      "optimal-foraging-reg-sum-of-squares"
;      "optimal-foraging-err-sum-of-squares"
;      
;      "mother-initiated-birth-regression-constant"
;      "mother-initiated-birth-regression-coeff"
;      "mother-initiated-birth-r-squared"
;      "mother-initiated-birth-adj-r-squared"
;      "mother-initiated-birth-F-statistic"
;      "mother-initiated-birth-probability-of-F"
;      "mother-initiated-birth-standard-error"
;      "mother-initiated-birth-tot-degrees-of-freedom"
;      "mother-initiated-birth-reg-degrees-of-freedom"
;      "mother-initiated-birth-err-degrees-of-freedom"
;      "mother-initiated-birth-tot-sum-of-squares"
;      "mother-initiated-birth-reg-sum-of-squares"
;      "mother-initiated-birth-err-sum-of-squares"
;      
;      "mother-initiated-wean-regression-constant"
;      "mother-initiated-wean-regression-coeff"
;      "mother-initiated-wean-r-squared"
;      "mother-initiated-wean-adj-r-squared"
;      "mother-initiated-wean-F-statistic"
;      "mother-initiated-wean-probability-of-F"
;      "mother-initiated-wean-standard-error"
;      "mother-initiated-wean-tot-degrees-of-freedom"
;      "mother-initiated-wean-reg-degrees-of-freedom"
;      "mother-initiated-wean-err-degrees-of-freedom"
;      "mother-initiated-wean-tot-sum-of-squares"
;      "mother-initiated-wean-reg-sum-of-squares"
;      "mother-initiated-wean-err-sum-of-squares"
;      
;      "hamiltons-rule-regression-constant"
;      "hamiltons-rule-regression-coeff"
;      "hamiltons-rule-r-squared"
;      "hamiltons-rule-adj-r-squared"
;      "hamiltons-rule-F-statistic"
;      "hamiltons-rule-probability-of-F"
;      "hamiltons-rule-standard-error"
;      "hamiltons-rule-tot-degrees-of-freedom"
;      "hamiltons-rule-reg-degrees-of-freedom"
;      "hamiltons-rule-err-degrees-of-freedom"
;      "hamiltons-rule-tot-sum-of-squares"
;      "hamiltons-rule-reg-sum-of-squares"
;      "hamiltons-rule-err-sum-of-squares"
      
      
;  ; STATISTICAL CALCULATIONS
;  
;  ; lotka volterra
;  let lotka-volterra-results (list 0 0 0 0 0 0 0 ) ; calculate-lotka-volterra
;  let lotka-volterra-best-fit item 0 lotka-volterra-results
;  let lotka-volterra-r1 item 1 lotka-volterra-results
;  let lotka-volterra-r2 item 2 lotka-volterra-results
;  let lotka-volterra-s12 item 3 lotka-volterra-results
;  let lotka-volterra-s21 item 4 lotka-volterra-results
;  let lotka-volterra-N1 item 5 lotka-volterra-results
;  let lotka-volterra-N2 item 6 lotka-volterra-results
;  
;  ; stats table with generation number in first column as dependent variable
;  ;let generation-table stats:newtable
;  ;stats:set-names generation-table ( list "generation-number" "optimal-foraging-index"  "mother-initiated-birth-percent" "mother-initiated-wean-percent" "hamiltons-rule-percent" )
;  
;  let stop-generation 10
;  let g 1
;  
;  while [ g < stop-generation ] [
;    
;    let sum-foraging-gains sum [foraging.gains] of anima1s with [ generation.number = g ]
;    let sum-energy-cost sum [total.energy.cost] of anima1s with [ generation.number = g ]
;    let generation-size count anima1s with [ generation.number = g ]
;    
;    let optimal-foraging-index ifelse-value ( sum-energy-cost > 0 ) [ sum-foraging-gains / sum-energy-cost ] [ 0 ]
;    let mother-initiated-birth-percent ifelse-value ( generation-size > 0 ) [ count anima1s with [ generation.number = g and mother.initiated.birth ] / generation-size ] [ 0 ]
;    let mother-initiated-wean-percent ifelse-value ( generation-size > 0 ) [ count anima1s with [ generation.number = g and mother.initiated.weaning ] / generation-size ] [ 0 ]
;    let hamiltons-rule-percent ifelse-value ( generation-size > 0 ) [ count anima1s with [ whole.related.help.cost > half.related.help.cost and half.related.help.cost > fourth.related.help.cost and fourth.related.help.cost > eighth.related.help.cost and generation.number = g ] / generation-size ] [ 0 ]
;    
;    ;stats:add generation-table ( list g optimal-foraging-index mother-initiated-birth-percent mother-initiated-wean-percent hamiltons-rule-percent )
;    
;    set g g + 1 ]
;
;  ; calculate correlations
;  let correlation-matrix 0 ;stats:correlation generation-table
;  
;  ; optimal foraging
;  let optimal-foraging-correlation 0 ;item 0 item 1 correlation-matrix
;  let optimal-foraging-regression-coeffs 0 ;stats:regress-on generation-table [ "generation-number" "optimal-foraging-index" ]
;  let optimal-foraging-regression-constant 0;first optimal-foraging-regression-coeffs
;  let optimal-foraging-regression-coeff 0 ;last optimal-foraging-regression-coeffs
;  let regression-stats 0 ;stats:get-rstats generation-table
;  let optimal-foraging-r-squared 0 ;item 0 regression-stats
;  let optimal-foraging-adj-r-squared 0 ;item 1 regression-stats
;  let optimal-foraging-F-statistic 0 ;item 2 regression-stats
;  let optimal-foraging-probability-of-F 0 ;item 3 regression-stats
;  let optimal-foraging-standard-error 0 ;item 4 regression-stats
;  let optimal-foraging-tot-degrees-of-freedom 0 ;item 5 regression-stats
;  let optimal-foraging-reg-degrees-of-freedom 0 ;item 6 regression-stats
;  let optimal-foraging-err-degrees-of-freedom 0 ;item 7 regression-stats
;  let optimal-foraging-tot-sum-of-squares 0 ;item 8 regression-stats
;  let optimal-foraging-reg-sum-of-squares 0 ;item 9 regression-stats
;  let optimal-foraging-err-sum-of-squares 0 ;item 10 regression-stats
;  
;  ; parent-offspring conflict at birth
;  let mother-initiated-birth-correlation 0 ;item 0 item 2 correlation-matrix
;  let mother-initiated-birth-regression-coeffs 0 ;stats:regress-on generation-table [ "generation-number" "mother-initiated-birth-percent" ]
;  let mother-initiated-birth-regression-constant 0 ;first mother-initiated-birth-regression-coeffs
;  let mother-initiated-birth-regression-coeff 0 ;last mother-initiated-birth-regression-coeffs
;  set regression-stats 0 ;stats:get-rstats 0 ;generation-table
;  let mother-initiated-birth-r-squared 0 ;item 0 regression-stats
;  let mother-initiated-birth-adj-r-squared 0 ;item 1 regression-stats
;  let mother-initiated-birth-F-statistic 0 ;item 2 regression-stats
;  let mother-initiated-birth-probability-of-F 0 ;item 3 regression-stats
;  let mother-initiated-birth-standard-error 0 ;item 4 regression-stats
;  let mother-initiated-birth-tot-degrees-of-freedom 0 ;item 5 regression-stats
;  let mother-initiated-birth-reg-degrees-of-freedom 0 ;item 6 regression-stats
;  let mother-initiated-birth-err-degrees-of-freedom 0 ;item 7 regression-stats
;  let mother-initiated-birth-tot-sum-of-squares 0 ;item 8 regression-stats
;  let mother-initiated-birth-reg-sum-of-squares 0 ;item 9 regression-stats
;  let mother-initiated-birth-err-sum-of-squares 0 ;item 10 regression-stats
;  
;  ; parent-offspring conflict at weaning
;  let mother-initiated-wean-correlation 0 ;item 0 item 3 correlation-matrix
;  let mother-initiated-wean-regression-coeffs 0 ;stats:regress-on generation-table [ "generation-number" "mother-initiated-wean-percent" ]
;  let mother-initiated-wean-regression-constant 0 ;first mother-initiated-wean-regression-coeffs
;  let mother-initiated-wean-regression-coeff 0 ;last mother-initiated-wean-regression-coeffs
;  set regression-stats 0 ;stats:get-rstats generation-table
;  let mother-initiated-wean-r-squared 0 ;item 0 regression-stats
;  let mother-initiated-wean-adj-r-squared 0 ;item 1 regression-stats
;  let mother-initiated-wean-F-statistic 0 ;item 2 regression-stats
;  let mother-initiated-wean-probability-of-F 0 ;item 3 regression-stats
;  let mother-initiated-wean-standard-error 0 ;item 4 regression-stats
;  let mother-initiated-wean-tot-degrees-of-freedom 0 ;item 5 regression-stats
;  let mother-initiated-wean-reg-degrees-of-freedom 0 ;item 6 regression-stats
;  let mother-initiated-wean-err-degrees-of-freedom 0 ;item 7 regression-stats
;  let mother-initiated-wean-tot-sum-of-squares 0 ;item 8 regression-stats
;  let mother-initiated-wean-reg-sum-of-squares 0 ;item 9 regression-stats
;  let mother-initiated-wean-err-sum-of-squares 0 ;item 10 regression-stats
; 
;  ; hamilton's rule
;  let hamiltons-rule-correlation 0 ;item 0 item 4 correlation-matrix
;  let hamiltons-rule-regression-coeffs 0; stats:regress-on generation-table [ "generation-number" "hamiltons-rule-percent" ]
;  let hamiltons-rule-regression-constant 0;  first hamiltons-rule-regression-coeffs
;  let hamiltons-rule-regression-coeff 0;  last hamiltons-rule-regression-coeffs
;  set regression-stats 0;  stats:get-rstats generation-table
;  let hamiltons-rule-r-squared 0;  item 0 regression-stats
;  let hamiltons-rule-adj-r-squared 0;  item 1 regression-stats
;  let hamiltons-rule-F-statistic 0;  item 2 regression-stats
;  let hamiltons-rule-probability-of-F 0;  item 3 regression-stats
;  let hamiltons-rule-standard-error  0; item 4 regression-stats
;  let hamiltons-rule-tot-degrees-of-freedom 0;  item 5 regression-stats
;  let hamiltons-rule-reg-degrees-of-freedom 0;  item 6 regression-stats
;  let hamiltons-rule-err-degrees-of-freedom 0;  item 7 regression-stats
;  let hamiltons-rule-tot-sum-of-squares 0;  item 8 regression-stats
;  let hamiltons-rule-reg-sum-of-squares 0;  item 9 regression-stats
;  let hamiltons-rule-err-sum-of-squares 0;  item 10 regression-stats
  

;to-report max-proximity [ target ] ; the max distance between two individuals (based on their body size - bigger individuals are in proximity from farther away)
;  ; distance measured between centers of bodies
;  report ( size / 2 + ( ifelse-value ( is-patch? target ) [ 1 ] [[size] of target / 2 ]))
;end

to attack-victims 
  ask anima1s with [ member? [my.identity] of myself attack.from.history ] [
    inspect self 
  ]
end



;-----------------------------------------------------------------------------       
; SEED POPULATION
;-----------------------------------------------------------------------------   

to seed-population
  let population-choice substring useful-commands 3 length useful-commands
  set path-to-experiment "../data/"
  set population population-choice
  set genotype population-choice
  import-population
end



;---------------------------------------------------------------------------------------------------------------------------------
; GUI OUPUT FUNCTIONS 
;---------------------------------------------------------------------------------------------------------------------------------

;to-report go-runtime
;  profiler:reset
;  profiler:start
;  repeat 1 [ go ]
;  report profiler:inclusive-time "go"
;end




;to reduce-to-unique-vectors
;
;  let initial-decisions decision.vectors
;  let reduced-decisions []
;
;  foreach initial-decisions [ original-vector ->
;    let original-ego item 0 original-vector
;    let original-target item 1 original-vector
;    let original-action item 2 original-vector
;    let original-weight item 3 original-vector
;    let vector-doesnt-exist true
;
;    let index 0
;    foreach reduced-decisions [ reduced-vector ->
;      let reduced-ego item 0 reduced-vector
;      let reduced-target item 1 reduced-vector
;      let reduced-action item 2 reduced-vector
;      let reduced-weight item 3 reduced-vector
;
;      if ( reduced-ego = original-ego ) and ( reduced-target = original-target ) and ( reduced-action = original-action ) [
;        set vector-doesnt-exist false
;        set reduced-weight ifelse-value ( is-number? reduced-weight ) [ reduced-weight ] [ 0 ]
;        set original-weight ifelse-value ( is-number? original-weight ) [ original-weight ] [ 0 ]
;        let new-vector ( list self reduced-target reduced-action ( reduced-weight + original-weight ) false )
;        set reduced-decisions remove-item index reduced-decisions
;        set reduced-decisions lput new-vector reduced-decisions ]
;      set index index + 1
;    ]
;    if vector-doesnt-exist [ set reduced-decisions lput ( list self original-target original-action original-weight false ) reduced-decisions ]
;  ]
;  set decision.vectors reduced-decisions
;end


;to get-decision [ g ]
;  let my-environment my.environment
;  let ego-status status-of self
;  if ( length g = 5 and is-string? item 1 g and is-string? item 2 g and is-string? item 3 g and is-number? item 4 g ) [ ; checks that allele correctly organized
;    let gene-ego item 1 g
;    let gene-other item 2 g
;    let gene-action item 3 g
;    let gene-weight item 4 g
;    
;    ; Check that first CODON matches self
;    if first-string-is-part-of-last? ( gene-ego ) ( ego-status ) [
;      
;      ; Consider status-of others in the environment
;      foreach my-environment [ other-guy ->
;        let other-status status-of other-guy 
;        
;        ; Check that second CODON matches other
;        if first-string-is-part-of-last? ( gene-other ) ( other-status ) [
;          
;          let distance-to-target distance other-guy
;          set distance-to-target ifelse-value ( distance-to-target > 1 ) [ distance-to-target ] [ 1 ]
;          print (list self other-guy ( sta7us-get-action gene-action ) precision ( gene-weight / ( distance-to-target ^ 2 )) 10 false ) 
;          
;        ]
;      ]
;    ]
;  ]  
;end


;
;;;-----------------------------------------------------------------------------       
;;; VIEW HISTORY
;;;-----------------------------------------------------------------------------   
;;
;;to output-history
;;  let anima1-to-inspect one-of anima1s with [ self = subject ]
;;  output-header (word " HISTORY : " ifelse-value ( anima1-to-inspect = nobody ) [ "all individuals" ] [ (word "individual " [my.identity ] of anima1-to-inspect ) ] )
;;  
;;  output-print ( word " Total energy gained: "
;;    ifelse-value ( anima1-to-inspect != nobody ) 
;;    [ [ precision total.energy.gains 2 ] of subject ] 
;;    [ ( word precision ( sum [ total.energy.gains ] of anima1s with [ biological.sex = "female"] ) 2 " (females) " precision ( sum [ total.energy.gains ] of anima1s with [ biological.sex = "male"] ) 2 " (males) " ) ] )
;;  
;;  output-print ( word " Total energy cost: "
;;    ifelse-value ( anima1-to-inspect != nobody ) 
;;    [ [ precision total.energy.cost 2 ] of subject ] 
;;    [ ( word precision ( sum [ total.energy.cost ] of anima1s with [ biological.sex = "female"] ) 2 " (females) " precision ( sum [ total.energy.cost ] of anima1s with [ biological.sex = "male"]) 2 " (males) " ) ] )
;;  
;;  output-print ( word " Total energy gained by foraging: "
;;    ifelse-value ( anima1-to-inspect != nobody ) 
;;    [ [ precision foraging.gains 2 ] of subject ] 
;;    [ ( word precision ( sum [ foraging.gains ] of anima1s with [ biological.sex = "female"] ) 2 " (females) " precision ( sum [ foraging.gains ] of anima1s with [ biological.sex = "male"]) 2 " (males) " ) ] )
;;  
;;  output-print ( word " Number of helpful behaviors: "
;;    ifelse-value ( anima1-to-inspect != nobody ) 
;;    [ [ length help.from.history ] of subject ] 
;;    [ ( word sum [ length help.from.history ] of anima1s with [ biological.sex = "female"] " (females) " sum [ length help.from.history ] of anima1s with [ biological.sex = "male"] " (males) " ) ] )
;;  
;;  output-print ( word " Number of aggressive behaviors: "
;;    ifelse-value ( anima1-to-inspect != nobody ) 
;;    [ [ length attack.from.history ] of subject ] 
;;    [ ( word sum [ length attack.from.history ] of anima1s with [ biological.sex = "female"] " (females) " sum [ length attack.from.history ] of anima1s with [ biological.sex = "male"] " (males) " ) ] )
;;  
;;  output-print ( word " Number of infanticides: "
;;    ifelse-value ( anima1-to-inspect != nobody ) 
;;    [ [ length infanticide.history ] of subject ] 
;;    [ ( word sum [ length infanticide.history ] of anima1s with [ biological.sex = "female"] " (females) " sum [ length infanticide.history ] of anima1s with [ biological.sex = "male"] " (males) " ) ] )
;;  
;;  output-print ( word " Number of copulations: "
;;    ifelse-value ( anima1-to-inspect != nobody ) 
;;    [ [ length copulations.history ] of subject ] 
;;    [ ( word sum [ length copulations.history ] of anima1s with [ biological.sex = "female"] " (females) " sum [ length copulations.history ] of anima1s with [ biological.sex = "male"] " (males) " ) ] )
;;  
;;  output-print ( word " Number of conceptions: "
;;    ifelse-value ( anima1-to-inspect != nobody ) 
;;    [ [ length conceptions.history ] of subject ] 
;;    [ ( word sum [ length conceptions.history ] of anima1s with [ biological.sex = "female"] " (females) " sum [ length conceptions.history ] of anima1s with [ biological.sex = "male"] " (males) " ) ] )
;;  
;;  output-print ( word " Number of group transfers: "
;;    ifelse-value ( anima1-to-inspect != nobody ) 
;;    [ [ length group.transfers.history ] of subject ] 
;;    [ ( word sum [ length group.transfers.history ] of anima1s with [ biological.sex = "female"] " (females) " sum [ length group.transfers.history ] of anima1s with [ biological.sex = "male"] " (males) " ) ] )
;;  
;;end
;;
;;;-----------------------------------------------------------------------------       
;;; VIEW STATUS
;;;-----------------------------------------------------------------------------   
;;
;;to output-status
;;  let anima1-to-inspect one-of anima1s with [ self = subject ]
;;  output-header (word " STATUS : " ifelse-value ( anima1-to-inspect = nobody ) [ "all individuals" ] [ (word "individual " [ my.identity ] of anima1-to-inspect ) ] )
;;  
;;  ;output-print ( word " Number of individuals: " count anima1z )
;;  output-print ( word " Number of females: " count anima1z with [ biological.sex = "female" ] )
;;  output-print ( word " Number of males: " count anima1z with [ biological.sex = "male" ] )
;;  
;;  let group-list []
;;  let group-size-list []
;;  let females-in-group []
;;  let males-in-group []
;;  let juveniles-in-group []
;;  let infants-in-group []
;;  let gestatees-in-group []
;;  
;;  ask anima1z [ if ( not member? group.identity group-list ) [ set group-list lput group.identity group-list ]]
;;  foreach group-list [ g -> 
;;    set group-size-list lput ( count anima1z with [ group.identity = g ] ) group-size-list 
;;    set females-in-group lput ( count anima1z with [ group.identity = g and biological.sex = "female" and life.history = "adult"] ) females-in-group 
;;    set males-in-group lput ( count anima1z with [ group.identity = g and biological.sex = "male" and life.history = "adult" ] ) males-in-group 
;;    set juveniles-in-group lput ( count anima1z with [ group.identity = g and life.history = "juvenile" ] ) juveniles-in-group
;;    set infants-in-group lput ( count anima1z with [ group.identity = g and life.history = "infant" ] ) infants-in-group
;;    set gestatees-in-group lput ( count anima1z with [ group.identity = g and life.history = "gestatee" ] ) gestatees-in-group
;;  ]
;;  
;;  output-print ( word " Number of groups: " length group-list )
;;  output-print ( word " Average group size: " precision mean group-size-list 2 )
;;  output-print ( word " Average number of adult females per group: " precision mean females-in-group 2 )
;;  output-print ( word " Average number of adult males per group: " precision mean males-in-group 2 )
;;  output-print ( word " Average number of juveniles per group: " precision mean juveniles-in-group 2 )
;;  output-print ( word " Average number of infants per group: " precision mean infants-in-group 2 )
;;  output-print ( word " Average number of gestatees per group: " precision mean gestatees-in-group 2 )
;;end
;
;
;
;
;
;
;
;
;
;
;






; save? - this one helps set a group to same color i think+
to-report get-group-identity-from-color [ color-of-group ]
  ifelse ( is-number? color-of-group ) [
    report ( random 999 * 140 + color-of-group )
  ][
    report "error: input value is not a number"
  ]
end


; save? - this one gives random chomrosome identities at first
to set-random-identity-chromosomes [ length-of-chromosomes ]
  let get-alphabet [ "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z" ]
  ifelse ( is-number? length-of-chromosomes ) [
    set identity.I ""
    set identity.II ""
    repeat length-of-chromosomes [ set identity.I (word identity.I one-of get-alphabet ) ]
    repeat length-of-chromosomes [ set identity.II (word identity.II one-of get-alphabet ) ]
  ][
    print "error: input value is not a number"
  ] 
end

;to plot-plants [ current-season plant-density ]
;
;  repeat 1000 [
;
;    let x random-float 8
;
;    let seasonal-factor ( ( plant-seasonality * current-season + 1 ) / 2 )
;    let optimal-neighbor-energy ( plant-minimum-neighbors + plant-maximum-neighbors ) / 2
;    let neighbor-energy-sd ( optimal-neighbor-energy - plant-minimum-neighbors )
;    let neighbor-energy x ;( ( sum [penergy.supply] of neighbors ) / plant-quality )
;
;    let probability-up ifelse-value ( neighbor-energy-sd = 0 ) [ 0 ] [ ( seasonal-factor * e ^ ( - (( neighbor-energy - optimal-neighbor-energy ) ^ 2 ) / ( 2 * ( neighbor-energy-sd ^ 2 ) )) ) ]
;    let y ( ( plant-daily-cycle * plant-quality ) / plant-annual-cycle ) * ( plant-density * ( 2 * probability-up - 1 ) + seasonal-factor - plant-density )
;
;    plotxy x y
;
;  ]
;
;end








;to-report get-column-results [ agent-list stats-list ]
;  
;  let report-list []
;  foreach stats-list [ i ->
;    set report-list (sentence report-list get-stats-results i agent-list )
;  ]
;  report report-list ; concatinated lists of numbers
;end
;
;to-report get-stats-results [ stats-type agent-list ]
;  ; foreach get-value-array, ( for each measurement done)
;  ;    apply stats-type to turn list into number
;  ; therefore end up with one list of numbers, or list of single number 
;  
;  ; return list of numbers
;  let report-list []
;  let values get-value-array agent-list selected-display  
;  
;  foreach values [ v -> 
;    set report-list (ifelse-value
;      ( stats-type = "min" ) [ min v ]
;      ( stats-type = "max" ) [ max v ]
;      ( stats-type = "mean" ) [ mean v ]
;      ( stats-type = "median" ) [ median v ]
;      ( stats-type = "variance" ) [ variance v ]
;      [ count v ])
;  ]
;  report report-list
;  
;;  report (ifelse-value
;;    ( stats-type = "min" ) [ min get-value-array agent-list selected-display ]
;;    [])
;end
;
;to-report get-value-array [ agent-list inputs ] ; returns a list of lists, one list for each measurement done on agent-list
;  let report-list []
;  
;;  foreach inputs [ input ->
;;  
;;  set report-list lput ( ifelse
;;;    ( input = "life-history" ) [ foreach [ "gestation" "lactation" "sexual-maturity" "longevity" ] [ l ->  set report-list lput ( get-value-array agent-list l ) report-list ]]
;;;    ( input = "genotype" )[ get-genotype-measurements agent-list ]
;;;    ( input = "phenotype" )[ get-phenotype-measurements agent-list ] ;
;;;    ( input = "kin-selection" )[ get-kin-sselection-measurements agent-list ] ;
;;;    ( input = "actions" )[ get-action-measurements agent-list ]
;;;    ( input = "decisions" )[ get-decision-measurements agent-list ]
;;    ( input = "age" ) [ set report-list lput [ age.in.ticks ] of agent-list ]
;;    ( input = "generations" ) [ generation.number ]
;;    ( input = "survival-chance" ) [ survival.chance ]
;;    ( input = "body-size" ) [ body.size ]
;;    ( input = "body-shade" ) [ body.shade ]
;;    ( input = "hidden-chance" ) [ hidden.chance ]
;;    ( input = "bite-capacity" ) [ bite.capacity ]    
;;    ( input = "mutation-chance" ) [ mutation.chance ]
;;    ( input = "sex-ratio" ) [ sex.ratio ]
;;    ( input = "litter-size" ) [ litter.size ]
;;    ( input = "conception-chance" ) [ conception.chance ]
;;    ( input = "visual-angle" ) [ visual.angle ]
;;    ( input = "visual-range" ) [ visual.range ]
;;    ( input = "day-perception" ) [ day.perception ]
;;    ( input = "night-perception" ) [ night.perception ]
;;    ( input = "yellow-chance" ) [ yellow.chance ]
;;    ( input = "red-chance" ) [ red.chance ]
;;    ( input = "blue-chance" ) [ blue.chance ]
;;    ( input = "birthing-chance" ) [ birthing.chance ]
;;    ( input = "weaning-chance" ) [ weaning.chance ]
;;    ( input = "infancy-chance" ) [ infancy.chance ]
;;    ( input = "juvenility-chance" ) [ juvenility.chance ]
;;    ( input = "adulthood-chance" ) [ adulthood.chance ]
;;    ( input = "carried-items" ) [ length carried.items ]
;;    ( input = "energy-supply" ) [ energy.supply ]
;;    ( input = "birthing" ) [ ifelse-value ( mother.initiated.birth = true ) [ 2 ] [ 1 ] ]
;;    ( input = "weaning" ) [ ifelse-value ( mother.initiated.weaning = true ) [ 2 ] [ 1 ] ]
;;    ( input = "matings" ) [ length copulations.history ]
;;    ( input = "mating-partners" ) [ length remove-duplicates copulations.history ]
;;    ( input = "conceptions" ) [ length conceptions.history ]
;;    ( input = "infanticide" ) [ length infanticide.history ]
;;    ( input = "group-transfers" ) [ length group.transfers.history ]
;;    ( input = "travel-distance" ) [ distance.traveled ]
;;    ( input = "foraging-gains" ) [ foraging.gains ]
;;    ( input = "total-energy-gains" ) [ total.energy.gains ]
;;    ( input = "total-energy-cost" ) [ total.energy.cost ]
;;    ( input = "receiving.history" ) [ receiving.history ]
;;    ( input = "carried.history" ) [ length carried.history ]
;;    ( input = "aid-history" ) [ length help.from.history ]
;;    ( input = "attack-history" ) [ length attack.from.history ]
;;      
;;    [])
;;  ]
; 
;  report report-list
;end
;
;to-report get-phenotype-measurements
;  
;end
;
;to-report get-genotype-measurements
;  report []
;end
;
;to plot-individuals-decisions 
;  let individual-list get-sorted-individuals                        ; get sorted list of living agents
;  let plot-list []                                                  ; initialize list of values to be plotted
;  
;  let decisions-list [ 
;    "survival-chance" "body-size" "body-shade" 
;    "day-perception" "night-perception" "visual-angle" "visual-range" 
;    "conception-chance" "bite-capacity" "mutation-chance" "sex-ratio" "litter-size" 
;    "turn-right" "turn-left" "go-forward" "set-heading" "set-heading-random" 
;    "hide" "rest" 
;    "yellow-signal" "red-signal" "blue-signal" 
;    "check-infancy" "check-juvenility" "check-adulthood" 
;    "check-birth" "check-weaning" 
;    "move-toward" "move-away-from" "supply-to" "demand-from" "eat"
;    "join" "leave" "recruit" "kick-out"
;    "pick-up" "put-down" "cling-to" "squirm-from"
;    "help" "hurt" "mate-with" ]
;  
;  let color-list [ 
;    3 5 7 
;    12 14 16 18
;    23 25 27 
;    33 37
;    43 45 47 
;    54 56
;    64 67
;    73 75 77
;    82 85 87
;    93 96 
;    103 107 
;    123 125 127
;    132 134 136 138
;    142 144 146 148
;    153 155 157 ]
;  
;  foreach individual-list [ i ->                                    ; loop through each individual
;    
;    foreach decisions-list [ d ->
;      
;      
;    
;;    ifelse ( subject = i )                                          ; check if individual is subject
;;    [ set plot-list lput (list 0 [age.in.ticks] of i ) plot-list ]  ; if yes, then update plot list for red columm
;;    [ set plot-list lput (list [age.in.ticks] of i 0 ) plot-list ]] ; if no, then update plot list for black column
;  ]]
;  ;plot-colored-histogram 1 plot-list color-list                      ; update plot based on plot list
;end
;  
;to plot-groups-groups 
;  let current-groups sort remove-duplicates [group.identity] of anima1s with [ is.alive ]
;  let group-composition-list []
;  
;  foreach current-groups [ group ->
;    let this-group-composition []
;    let y-so-far count anima1s with [ is.alive and group.identity = group ]
;    foreach [ "gestatee" "infant" "juvenile" "adult" ] [ life-stage ->      
;      foreach [ "female" "male" ] [ sex ->
;        set this-group-composition lput y-so-far this-group-composition
;        set y-so-far y-so-far - count anima1s with [ is.alive and group.identity = group and life.history = life-stage and biological.sex = sex ]
;      ]
;    ]
;    set group-composition-list lput this-group-composition group-composition-list
;  ] 
;  ;plot-colored-histogram 1 group-composition-list [ red orange yellow green turquoise sky blue magenta ]
;end
;  
;to plot-lotka-volterra 
;  clear-all-plots
;  set-plot-pen-mode 0
;  set-plot-pen-color green
;  let index 0
;  foreach plant-abundance-record [ p ->
;    plotxy ( 100 * index ) ( ln p )
;    set index index + 1 ]
;  plot-pen-up
;  set index 0
;  set-plot-pen-color brown
;  foreach population-size-record [ s ->
;    plotxy ( 100 * index ) ( ln s )
;    plot-pen-down
;    set index index + 1 ]
;end
;
;
;to reduce-genotype
;  clear-output
;  ;REDUCE DECISIONS TO ONE PER TARGET-ACTION COMBO
;  let reduced-decisions []
;  
;  let input-list ( sentence chromosome.i chromosome.ii )
;  
;  foreach input-list [ original-vector ->
;    let original-ego ifelse-value ( length original-vector > 1 ) [ item 1 original-vector ] [ 0 ]
;    let original-target ifelse-value ( length original-vector > 2 ) [ item 2 original-vector ] [ 0 ]
;    let original-action ifelse-value ( length original-vector > 3 ) [ item 3 original-vector ] [ 0 ]
;    let original-weight ifelse-value ( length original-vector > 4 ) [ item 4 original-vector ] [ 0 ]
;    let vector-doesnt-exist true
;    
;    let index 0
;    foreach reduced-decisions [ reduced-vector ->
;      let reduced-ego ifelse-value ( length reduced-vector > 1 ) [ item 1 reduced-vector ] [ 0 ]
;      let reduced-target ifelse-value ( length reduced-vector > 2 ) [ item 2 reduced-vector ] [ 0 ]
;      let reduced-action ifelse-value ( length reduced-vector > 3 ) [ item 3 reduced-vector ] [ 0 ]
;      let reduced-weight ifelse-value ( length reduced-vector > 4 ) [ item 4 reduced-vector ] [ 0 ]
;      
;      print original-ego
;      print original-target
;      print original-action
;      print original-weight
;      print reduced-ego
;      print reduced-target
;      print reduced-action
;      print reduced-weight
;      
;      if ( reduced-ego = original-ego ) and ( reduced-target = original-target ) and ( reduced-action = original-action ) and is-number? reduced-weight and is-number? original-weight [
;        set vector-doesnt-exist false
;        print "match"
;        let new-vector ( list reduced-ego reduced-target reduced-action ( reduced-weight + original-weight ) )
;        set reduced-decisions remove-item index reduced-decisions
;        set reduced-decisions lput new-vector reduced-decisions ]
;      set index index + 1
;    ]
;    if vector-doesnt-exist [ set reduced-decisions lput ( list original-ego original-target original-action original-weight ) reduced-decisions ]
;    ; print reduced-decisions
;  ]
;  foreach reduced-decisions [ d ->
;    output-print d
;  ]
;end
;
;
;
;
;
;;; detelet?
;
;
;
;
;
;
;
;;-----------------------------------------------------------------------------       
;; AGE HISTOGRAM
;;-----------------------------------------------------------------------------    
;
;;to age-histogram
;;  clear-plot
;;  set-plot-pen-interval 100
;;  set-plot-x-range 0 max [ age.in.ticks ] of anima1s with [ is.alive ]
;;  histogram [ age.in.ticks ] of anima1s with [ is.alive ]
;;end








; --------------------------------------------------------------------------------------------------------- ;     
;     
; POPULATION
;
; ENTRY
;
; EXIT
;
; --------------------------------------------------------------------------------------------------------- ;

;to plot-population-histogram  ; works! bad runtime
;  let max-value max [ get-result-from-selected-display ] of anima1z
;  let column-no 10
;  let interval precision ( max-value / column-no ) 2
;  let plot-list []
;  let lower 0
;  let upper lower + interval
;  let selected-individuals get-sorted-individuals
;  let row-list []
;  repeat column-no [
;   ; print lower
;    ;print upper
;    set row-list lput (word " " lower " to " upper "") row-list
;    let agent-count count anima1z with [ get-result-from-selected-display > lower and get-result-from-selected-display <= upper and member? self selected-individuals]
;    ;let subject? any? anima1z with [ subject = self and get-result-from-selected-display > lower and get-result-from-selected-display <= upper and member? self selected-individuals]
;    set plot-list lput ( list agent-count ifelse-value ( member? subject selected-individuals ) [ agent-count ][ 0 ] ) plot-list
;    set lower lower + interval
;    set upper upper + interval ]
;  ;print plot-list
;  plot-colored-histogram interval plot-list [ black red ] 1
;  
;  ;output-window input "" (list "column" "interval" "count" ) row-list plot-list 0 0 0
;end



; --------------------------------------------------------------------------------------------------------- ;
;
; PRINT SPECIFIED AGENT INFORMATION TO OUTPUT WINDOW
;
; This subroutine...
;
; ENTRY
;
; EXIT
;
; --------------------------------------------------------------------------------------------------------- ;

to print-life-history-key
  output-print " PLOT KEY :"
  output-print " blue : adult male "
  output-print " pink : cycling female" 
  output-print " magenta : pregnant female"
  output-print " purple : lactating female"
  output-print " brown : juvenile male "
  output-print " orange : juvenile female" 
  output-print " mustard : infant male"
  output-print " sunflower : infant female "
  output-print " forest : gestatee male" 
  output-print " lime : gestatee female"
end










; --------------------------------------------------------------------------------------------------------- ;
;
; PRINT SPECIFIED AGENT INFORMATION TO OUTPUT WINDOW
;
; This subroutine...
;
; ENTRY
;
; EXIT
;
; --------------------------------------------------------------------------------------------------------- ;

to-report life-history-number
  report (ifelse-value
    ( life.history = "adult" ) [ 1 ]
    ( life.history = "juvenile" ) [ 2 ]
    ( life.history = "infant" ) [ 3 ]
    ( life.history = "gestatee" ) [ 4 ]
    [ 5 ])
end


; --------------------------------------------------------------------------------------------------------- ;
;
; PRINT SPECIFIED AGENT INFORMATION TO OUTPUT WINDOW
;
; This subroutine...
;
; ENTRY
;
; EXIT
;
; --------------------------------------------------------------------------------------------------------- ;

to-report get-plot-focus-filter
  report (ifelse-value
  ( plot-type = "individuals" )[ "Individuals" ]
  ( plot-type = "groups" )[ "Groups" ]
  ( plot-type = "population" )[ "Population" ]
  ( plot-type = "generations" )[ "Generations" ]
  [ "" ])    
end



to generate-jobs
  
  let worlds [ "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" ]
  let min-neighbors [ 0 1 2 3 4 5 6 7 ]
  let max-neighbors [ 1 2 3 4 5 6 7 8 ]
  let A-or-B [ "A" "B" ]
  
  file-open ( word path-to-experiment "thesis.sh" )
  file-print "#!/bin/bash -l"
  
  foreach worlds [ w ->
    
    file-open ( word path-to-experiment "thesis.sh" )
    file-print ( word "./World-" w ".sh" )
    
    file-close
    
    file-open ( word path-to-experiment "World-" w ".sh" )
    file-print "#!/bin/bash -l"
    
    foreach min-neighbors [ n ->
      
      foreach max-neighbors [ x ->
        
        foreach A-or-B [ z ->
          
          if ( n < x ) [
            
            let name (word w n x z )
            
            file-open ( word path-to-experiment "World-" w ".sh" )
            file-print ( word "sbatch " name ".sh" )
            
            file-close
            
            file-open ( word path-to-experiment name ".sh" )
            
            file-print "#!/bin/bash -l"
            file-print "#SBATCH --time=96:00:00"
            file-print "#SBATCH --ntasks=24"
            file-print "#SBATCH --mem=60g"
            file-print "#SBATCH --mail-type=ALL"
            file-print "#SBATCH --mail-user=crou0048@umn.edu"
            file-print "export JAVA_HOME=/usr/java/jre1.8.0_101"
            file-print (word "/home/lehmanc/crou0048/Desktop/NetLogo\\ 6.2.0/netlogo-headless.sh --model /home/lehmanc/crou0048/Desktop/B3GET/code/B3GET.nlogo --setup-file thesis-experiments.xml --experiment " name " --threads 4")
            
            file-close
            
  ]]]]]
  
end

to generate-experiments
  
  file-open ( word path-to-experiment "thesis-experiments.xml" )
  
  file-print "<experiments>"
 
  let worlds [ "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" ]
  let min-neighbors [ 0 1 2 3 4 5 6 7 ]
  let max-neighbors [ 1 2 3 4 5 6 7 8 ]
  let A-or-B [ "A" "B" ]
  
  foreach worlds [ w ->
    
    foreach min-neighbors [ n ->
      
      foreach max-neighbors [ x ->
        
        foreach A-or-B [ z ->
          
          if ( n < x ) [
            
            let name (word w n x z )
            file-print ( word "  <experiment name=\"" name "\" repetitions=\"1\" runMetricsEveryStep=\"false\">" )
            file-print ( word "    <setup>thesis-setup</setup>" )
            file-print ( word "    <go>go</go>" )
            file-print ( word "    <final>thesis-final</final>" )
            file-print ( word "    <enumeratedValueSet variable=\"population\">" )
            file-print ( word "      <value value=\"&quot;Chimpanzees&quot;\"/>" )
            file-print ( word "      <value value=\"&quot;Geladas&quot;\"/>" )
            file-print ( word "      <value value=\"&quot;Hamadryas&quot;\"/>" )
            file-print ( word "      <value value=\"&quot;Olives&quot;\"/>" )
            file-print ( word "    </enumeratedValueSet>" )
            file-print ( word "  </experiment>" )
            
  ]]]]]
  
  file-print "</experiments>"
  file-close
  
end


to protopan-generate-experiments
  
  file-open ( word path-to-experiment "protopan.xml" )
  
  file-print "<experiments>"
 
  let plants [ "P" "H" ]
  let seasonality [ "S" "C" ]
  let quality [ 3 4 5 6 ]
  let A-D [ "A" "B" "C" "D" ]
  
  foreach plants [ p ->
    
    foreach seasonality [ s ->
      
      foreach A-D [ z ->
        
        let name ( word p s z )
        file-print ( word "  <experiment name=\"" name "\" repetitions=\"1\" runMetricsEveryStep=\"false\">" )
        file-print ( word "    <setup>protopan-setup</setup>" )
        file-print ( word "    <go>go</go>" )
        file-print ( word "    <final>protopan-final</final>" )
        file-print ( word "    <enumeratedValueSet variable=\"plant-quality\">" )
        file-print ( word "      <value value=\"5\"/>" )
        file-print ( word "      <value value=\"6\"/>" )
        file-print ( word "      <value value=\"7\"/>" )
        file-print ( word "      <value value=\"8\"/>" )
        file-print ( word "    </enumeratedValueSet>" )
        file-print ( word "  </experiment>" )
        
  ]]]
  
  file-print "</experiments>"
  file-close
  
end


to protopan-generate-jobs
  
  let plants [ "P" "H" ]
  let seasonality [ "S" "C" ]
  let quality [ 3 4 5 6 ]
  let A-D [ "A" "B" "C" "D" ]
  
  file-open ( word path-to-experiment "protopan.sh" )
  file-print "#!/bin/bash -l"
  
  foreach plants [ p ->
    
    foreach seasonality [ s ->
      
      foreach A-D [ z ->
        
        let name (word p s z )
        
        file-open ( word path-to-experiment "protopan.sh" )
        file-print ( word "sbatch -p max " name ".sh" )
        
        file-close
        
        file-open ( word path-to-experiment name ".sh" )
        
        file-print "#!/bin/bash -l"
        file-print "#SBATCH --time=30-0:00:00"
        file-print "#SBATCH --ntasks=24"
        file-print "#SBATCH --mem=60g"
        file-print "#SBATCH --mail-type=ALL"
        file-print "#SBATCH --mail-user=crou0048@umn.edu"
        file-print "export JAVA_HOME=/usr/java/jre1.8.0_101"
        file-print (word "/home/lehmanc/crou0048/Desktop/NetLogo\\ 6.2.0/netlogo-headless.sh --model /home/lehmanc/crou0048/Desktop/B3GET/code/B3GET.nlogo --setup-file protopan.xml --experiment " name " --threads 4")
        
        file-close
        
  ]]]
  
end

to protopan-setup
  
  clear-all                                                    ; Delete all current settings in the simulation.
  reset-ticks                                                  ; Reset the timesteps to zero.
  
  set path-to-experiment "../results/ProtoPan/"
  set genotype-reader "sta2us"
  set output-results? true 
  set selection-on? false
  set plant-annual-cycle 1000
  set plant-daily-cycle 10
  ;set plant-seasonality 0.5
  ;set plant-quality 4
  set deterioration-rate -0.01
  
  ;set maximum-population-size 200
  ;set minimum-population-size 200
  
  ; final settings 
  set simulation-summary-ticks 100000 
  set simulation-scan-ticks 250 
  set group-scan-ticks 100000 
  set individual-scan-ticks 0 
  set view-scan-ticks 100000 
  set genotype-scan-ticks 10000
  set focal-follow-rate 1E-4
  set record-individuals true 
  set verification-rate 1E-5
  set record-world-ticks 1000000
  set simulation-stop-at 200
  
  set population "ProtoPan"
  set genotype "protopan"
  
;  set simulation-summary-ticks 500 
;  set simulation-scan-ticks 250 
;  set group-scan-ticks 100
;  set individual-scan-ticks 0 
;  set view-scan-ticks 100
;  set genotype-scan-ticks 100
;  set focal-follow-rate 1E-3 
;  set record-individuals true 
;  set verification-rate 1E-5
;  set record-world-ticks 1000
;  set simulation-stop-at 200
  
  if ( model-structure = 0 ) [ set model-structure [] ]
 
 ; TO DO FOR PROTOPAN
  
  if ( first behaviorspace-experiment-name = "P" ) [ set plant-minimum-neighbors 4 set plant-maximum-neighbors 7 ]
  if ( first behaviorspace-experiment-name = "H" ) [ set plant-minimum-neighbors 0 set plant-maximum-neighbors 7 ]
  if ( item 1 behaviorspace-experiment-name = "S" ) [ set plant-seasonality 1 ]
  if ( item 1 behaviorspace-experiment-name = "C" ) [ set plant-seasonality 0 ]
  
  
  
;  ( ifelse
;    ( first behaviorspace-experiment-name = "A" ) [  ]
;    ( first behaviorspace-experiment-name = "B" ) [ set plant-annual-cycle 10000 set plant-daily-cycle 100 ]
;    ( first behaviorspace-experiment-name = "C" ) [ set plant-annual-cycle 10000 ]
;    ( first behaviorspace-experiment-name = "D" ) [ set plant-daily-cycle 100 ]
;    ( first behaviorspace-experiment-name = "E" ) [ set plant-seasonality 0 ]
;    ( first behaviorspace-experiment-name = "F" ) [ set plant-seasonality 1 ]
;    ( first behaviorspace-experiment-name = "G" ) [ set plant-quality 2 ]
;    ( first behaviorspace-experiment-name = "H" ) [ set plant-quality 6 ]
;    ( first behaviorspace-experiment-name = "I" ) [ set deterioration-rate -0.001 ]
;    ( first behaviorspace-experiment-name = "J" ) [ set model-structure lput "aspatial" model-structure ]
;    ( first behaviorspace-experiment-name = "K" ) [ set model-structure lput "stork" model-structure ]
;    ( first behaviorspace-experiment-name = "L" ) [ set model-structure lput "reaper" model-structure ]
;    ( first behaviorspace-experiment-name = "M" ) [ 
;      set model-structure lput "ideal-form" model-structure set model-structure lput "stork" model-structure ]
;    ( first behaviorspace-experiment-name = "N" ) [ set model-structure lput "free-lunch" model-structure ]
;    ( first behaviorspace-experiment-name = "O" ) [ set model-structure lput "no-evolution" model-structure ]
;    ( first behaviorspace-experiment-name = "P" ) [ set model-structure lput "uninvadable" model-structure ]
;    [  ] )
;  
;  if ( length behaviorspace-experiment-name = 4 ) [
;    
;    set plant-minimum-neighbors read-from-string ( item 1 behaviorspace-experiment-name )
;    set plant-maximum-neighbors read-from-string ( item 2 behaviorspace-experiment-name )
;    
;    ( ifelse 
;      ( population = "Chimpanzees" ) [
;        set genotype "chimpanzees" ]
;      ( population = "Geladas")[
;        set genotype "geladas" ]
;      ( population = "Hamadryas" )[
  ;        set genotype "hamadryas" ]
  ;      ( population = "Olives" )[
  ;        set genotype "olives" ]
  ;      [])
  ;    
  ;]
  
  set simulation-id ( word 
    generate-simulation-id
    "-"
    item 0 behaviorspace-experiment-name 
    item 1 behaviorspace-experiment-name 
    plant-quality
    item 2 behaviorspace-experiment-name )
  
  setup-parameters                                             ; Setup the global parameter settings.
  setup-patches                                                ; Initialize the plants for a new simulation.
  import-population                                            ; Create an initial population of indiviudals
  import-genotype                                              ; and their genotypes from user files.
  
  output-print (word                                           ; Once setup is complete, display the current
    " Simulation " simulation-id " "                           ; state of the new simulation.
    behaviorspace-run-number " end setup at "
    date-and-time " with starting-seed "
    starting-seed )
  
end

to dine-and-dash-setup
  protopan-setup
  set useful-commands "-- dine-and-dash"
  visual-verification
end

to protopan-final
  simulation-summary
  if ( record-individuals ) [ ask anima1s with [ is.alive ] [ individual-summary ]]
end


to protopan-BYTE-extraction
  
  let selected-byte-worlds [ 
    "wAC46A" "wAC46B" "wAC24A" "wAC24B" "wEC46A" "wEC46B" "wEC24A" "wEC24B"
    "wFC46A" "wFC46B" "wFC24A" "wFC24B" "wGC46A" "wGC46B" "wGC24A" "wGC24B" 
    "wHC46A" "wHC46B" "wHC24A" "wHC24B" ]
  
  foreach selected-byte-worlds [ w -> 
    
    let file-path ( word "../results/results-to-ignore/BYTE/b3get-output/" w "-100000.csv" )
    import-world file-path
    
    set path-to-experiment "../results/ProtoPan/"
;    simulation-summary
;    
;    reset-perspective                                         
;    export-view ( word path-to-experiment                     
;      "view-" simulation-id "-" ticks ".png")                 
;    output-territories                                        
;    export-view ( word path-to-experiment                  
;      "territories-" simulation-id "-" ticks ".png")  
;    
;    if ( any? anima1s with [ is.alive ] ) [                       
;      scan-genotype ] 
    
    ask anima1s with [ is.alive = false and generation.number > ( max [generation.number] of anima1s - 3 ) and life.history = "adult" ] [
      fill-in-blank-data
      individual-summary
    ]
    
  ]
  
end


; --------------------------------------------------------------------------------------------------------- ;
; PUT BACK IN SEX-SPECIFIC DATA ON ATTACK AND HELP FROM BYTE SIMULATIONS
; --------------------------------------------------------------------------------------------------------- ;

to fill-in-blank-data
  
  let target self
  
  foreach attack.from.history [ i ->
    
    let ego one-of anima1s with [ my.identity = i ]
    
    if ( [life.history] of ego = "adult" and [life.history] of target = "adult" and [biological.sex] of ego = "male" and [group.identity] of ego = [group.identity] of target ) [
      set from.ingroup.male.attack.count from.ingroup.male.attack.count + 1 ]
    if ( [life.history] of ego = "adult" and [life.history] of target = "adult" and [biological.sex] of ego = "male" and [group.identity] of ego != [group.identity] of target ) [
      set from.nongroup.male.attack.count from.nongroup.male.attack.count + 1 ]
    if ( [life.history] of ego = "adult" and [life.history] of target = "adult" and [biological.sex] of ego = "female" and [group.identity] of ego = [group.identity] of target ) [
      set from.ingroup.female.attack.count from.ingroup.female.attack.count + 1 ]
    if ( [life.history] of ego = "adult" and [life.history] of target = "adult" and [biological.sex] of ego = "female" and [group.identity] of ego != [group.identity] of target ) [
      set from.nongroup.female.attack.count from.nongroup.female.attack.count + 1 ]
    
    if ( [life.history] of ego = "adult" and [life.history] of target = "adult" and [biological.sex] of target = "male" and [group.identity] of ego = [group.identity] of target ) [
      ask target [ set to.ingroup.male.attack.count to.ingroup.male.attack.count + 1 ]]
    if ( [life.history] of ego = "adult" and [life.history] of target = "adult" and [biological.sex] of target = "male" and [group.identity] of ego != [group.identity] of target ) [
      ask target [ set to.nongroup.male.attack.count to.nongroup.male.attack.count + 1]]
    if ( [life.history] of ego = "adult" and [life.history] of target = "adult" and [biological.sex] of target = "female" and [group.identity] of ego = [group.identity] of target ) [
      ask target [ set to.ingroup.female.attack.count to.ingroup.female.attack.count + 1 ]]
    if ( [life.history] of ego = "adult" and [life.history] of target = "adult" and [biological.sex] of target = "female" and [group.identity] of ego != [group.identity] of target ) [
      ask target [ set to.nongroup.female.attack.count to.nongroup.female.attack.count + 1]]
    
  ]
  
  foreach help.from.history [ j ->
    
    let ego one-of anima1s with [ my.identity = j ]
    
    if ( [life.history] of ego = "adult" and [life.history] of target = "adult" and [biological.sex] of ego = "male" and [group.identity] of ego = [group.identity] of target ) [
      set from.ingroup.male.help.count from.ingroup.male.help.count + 1 ]
    if ( [life.history] of ego = "adult" and [life.history] of target = "adult" and [biological.sex] of ego = "male" and [group.identity] of ego != [group.identity] of target ) [
      set from.nongroup.male.help.count from.nongroup.male.help.count + 1 ]
    if ( [life.history] of ego = "adult" and [life.history] of target = "adult" and [biological.sex] of ego = "female" and [group.identity] of ego = [group.identity] of target ) [
      set from.ingroup.female.help.count from.ingroup.female.help.count + 1 ]
    if ( [life.history] of ego = "adult" and [life.history] of target = "adult" and [biological.sex] of ego = "female" and [group.identity] of ego != [group.identity] of target ) [
      set from.nongroup.female.help.count from.nongroup.female.help.count + 1 ]
    
    if ( [life.history] of ego = "adult" and [life.history] of target = "adult" and [biological.sex] of target = "male" and [group.identity] of ego = [group.identity] of target ) [
      ask target [ set to.ingroup.male.help.count to.ingroup.male.help.count + 1 ]]
    if ( [life.history] of ego = "adult" and [life.history] of target = "adult" and [biological.sex] of target = "male" and [group.identity] of ego != [group.identity] of target ) [
      ask target [ set to.nongroup.male.help.count to.nongroup.male.help.count + 1 ]]
    if ( [life.history] of ego = "adult" and [life.history] of target = "adult" and [biological.sex] of target = "female" and [group.identity] of ego = [group.identity] of target ) [
      ask target [ set to.ingroup.female.help.count to.ingroup.female.help.count + 1 ]]
    if ( [life.history] of ego = "adult" and [life.history] of target = "adult" and [biological.sex] of target = "female" and [group.identity] of ego != [group.identity] of target ) [
      ask target [ set to.nongroup.female.help.count to.nongroup.female.help.count + 1 ]]
    
  ]
  
end

; ========================================================================================================= ;
; 
;                                                                                    
; .d888888  888888ba   .d888888  dP        dP    dP .d88888b  dP .d88888b  
;d8'    88  88    `8b d8'    88  88        Y8.  .8P 88.    "' 88 88.    "' 
;88aaaaa88a 88     88 88aaaaa88a 88         Y8aa8P  `Y88888b. 88 `Y88888b. 
;88     88  88     88 88     88  88           88          `8b 88       `8b 
;88     88  88     88 88     88  88           88    d8'   .8P 88 d8'   .8P 
;88     88  dP     dP 88     88  88888888P    dP     Y88888P  dP  Y88888P  
;                                                                          
;            
; Â© 2021 K N Crouse  
; ========================================================================================================= ;

to thesis-setup
  
  clear-all                                                    ; Delete all current settings in the simulation.
  reset-ticks                                                  ; Reset the timesteps to zero.
  
  set path-to-experiment "../results/thesis/"
  set genotype-reader "sta2us"
  set output-results? true 
  set selection-on? false
  set plant-annual-cycle 1000
  set plant-daily-cycle 10
  set plant-seasonality 0.5
  set plant-quality 5
  set deterioration-rate -0.01

  set simulation-summary-ticks 5000 
  set simulation-scan-ticks 250 
  set group-scan-ticks 1000 
  set individual-scan-ticks 0 
  set view-scan-ticks 1000 
  set genotype-scan-ticks 1000
  set focal-follow-rate 0
  set record-individuals true 
  set verification-rate 1E-6
  set record-world-ticks 0
  set simulation-stop-at 10000
  
  set plant-maximum-neighbors read-from-string last behaviorspace-experiment-name
  
  ( ifelse
    ( first behaviorspace-experiment-name = "A" ) [ 
      set focal-follow-rate 1E-4 
      set record-individuals true 
      set record-world-ticks 10000 ]
    ( first behaviorspace-experiment-name = "B" ) [ set genotype-reader "gat3s" ]
    ( first behaviorspace-experiment-name = "C" ) [ set plant-annual-cycle 10000 ]
    ( first behaviorspace-experiment-name = "D" ) [ set plant-daily-cycle 100 ]
    ( first behaviorspace-experiment-name = "E" ) [ set plant-seasonality 0 ]
    ( first behaviorspace-experiment-name = "F" ) [ set plant-seasonality 1 ]
    ( first behaviorspace-experiment-name = "G" ) [ set plant-quality 1 ]
    ( first behaviorspace-experiment-name = "H" ) [ set plant-quality 5 ]
    ( first behaviorspace-experiment-name = "I" ) [ set deterioration-rate -0.001 ]
    ( first behaviorspace-experiment-name = "J" ) [ set model-structure lput "aspatial" model-structure ]
    ( first behaviorspace-experiment-name = "K" ) [ set model-structure lput "reaper" model-structure ]
    ( first behaviorspace-experiment-name = "L" ) [ set model-structure lput "stork" model-structure ]
    ( first behaviorspace-experiment-name = "M" ) [ set model-structure lput "ideal-form" model-structure ]
    ( first behaviorspace-experiment-name = "N" ) [ 
      set model-structure lput "free-lunch" model-structure 
      set model-structure lput "reaper" model-structure ]
    ( first behaviorspace-experiment-name = "O" ) [ set model-structure lput "no-evolution" model-structure ]
    ( first behaviorspace-experiment-name = "P" ) [ set model-structure lput "uninvadable" model-structure ]
    [  ] )
  
  ( ifelse 
    ( item 1 behaviorspace-experiment-name = "C" ) [
      set population "Chimpanzees"
      set genotype "chimpanzees" ]
    ( item 1 behaviorspace-experiment-name = "G" )[
      set population "Geladas"
      set genotype "geladas" ]
    ( item 1 behaviorspace-experiment-name = "H" )[
      set population "Hamadryas"
      set genotype "hamadryas" ]
    ( item 1 behaviorspace-experiment-name = "O" )[
      set population "Olives"
      set genotype "olives" ]
    [])
  
  ; give simulation-id specific configuration: sDO17B means
  ; simulation of WORLD-D, Baboons seed population,
  ; run B (instead of A), plant-minimum-neighbors = 1 and
  ; plant-maximum-neighbors = 7
  ifelse ( plant-minimum-neighbors < plant-maximum-neighbors ) [
    print "if"
    print ( word "s" but-last behaviorspace-experiment-name plant-minimum-neighbors plant-maximum-neighbors "A" )
    set simulation-id ( word "s" but-last behaviorspace-experiment-name plant-minimum-neighbors plant-maximum-neighbors "A" )
    print simulation-id
  ][
    let min-holder plant-minimum-neighbors
    let max-holder plant-maximum-neighbors
    set plant-minimum-neighbors max-holder - 1
    set plant-maximum-neighbors min-holder
    set simulation-id ( word "s" but-last behaviorspace-experiment-name plant-minimum-neighbors plant-maximum-neighbors "B" )
    print "else"
  ]
  
  setup-parameters                                             ; Setup the global parameter settings.
  setup-patches                                                ; Initialize the plants for a new simulation.
  import-population                                            ; Create an initial population of indiviudals
  import-genotype                                              ; and their genotypes from user files.
  
  output-print (word                                           ; Once setup is complete, display the current
    " Simulation " simulation-id " "                           ; state of the new simulation.
    behaviorspace-run-number " end setup at "
    date-and-time )
  
end

;reduce-to-unique-vectors                                     ; Reduce to unique set of decision vectors

; --------------------------------------------------------------------------------------------------------- ;
;
; HELPER SUBROUTINE TO REDUCE LIST OF DECISIONS TO UNIQUE COMBINATIONS OF TARGET AND ACTION
;
; This subroutine reduces the current list of decision vectors into a list of unique vectors such that
; there is only one vector for each combination of target and action. During this reduction processes, the
; decision vector weights are added together resulting in a decision vector with the net weight.
;
; ENTRY: Initial list of decision vectors before reduction process.
;
; EXIT:  Final list of decision vectors after the reduction process.
;
; --------------------------------------------------------------------------------------------------------- ;

to reduce-to-unique-vectors

  let initial-decisions decision.vectors                         ; Initially, there is a full list of decisions
  let reduced-decisions []                                       ; and an empty list.

  foreach initial-decisions [ original-vector ->                 ; Looping through the full list of decisions,
    let original-ego item 0 original-vector                      ; identify the caller,
    let original-target item 1 original-vector                   ; identity the target,
    let original-action item 2 original-vector                   ; identity the action,
    let original-weight item 3 original-vector                   ; identify the cost.

    let vector-doesnt-exist true                                 ;

    let index 0                                                  ;
    foreach reduced-decisions [ reduced-vector ->                ;
      let reduced-ego item 0 reduced-vector                      ;
      let reduced-target item 1 reduced-vector                   ;
      let reduced-action item 2 reduced-vector                   ;
      let reduced-weight item 3 reduced-vector                   ;

      if ( reduced-ego = original-ego )                          ;
      and ( reduced-target = original-target )                   ;
      and ( reduced-action = original-action ) [                 ;

        set vector-doesnt-exist false                            ;

        set reduced-weight ifelse-value                          ;
        ( is-number? reduced-weight )                            ;
        [ reduced-weight ]                                       ;
        [ 0 ]                                                    ;

        set original-weight ifelse-value                         ;
        ( is-number? original-weight )                           ;
        [ original-weight ]                                      ;
        [ 0 ]                                                    ;

        let new-vector ( list                                    ;
          self                                                   ;
          reduced-target                                         ;
          reduced-action                                         ;
          ( reduced-weight + original-weight )                   ;
          false )                                                ;

        set reduced-decisions                                    ;
        remove-item index reduced-decisions                      ;

        set reduced-decisions                                    ;
        lput new-vector reduced-decisions ]                      ;

      set index index + 1                                        ;
    ]

    if vector-doesnt-exist [                                     ;
      set reduced-decisions lput                                 ;
      ( list                                                     ;
        self                                                     ;
        original-target                                          ;
        original-action                                          ;
        original-weight                                          ;
        false )                                                  ;
      reduced-decisions ]                                        ;
  ]
  set decision.vectors reduced-decisions                         ;
end

to match-heading [ target cost ]
  complete-action target "match-heading" cost
;  ;print heading
;  ;print [heading] of target
  ;  let total-cost 10 * cost / ( abs deterioration-rate ) ; scaled with deterioration rate
  ;  let heading-difference subtract-headings heading [heading] of target
  ;  ;print heading-difference
  ;  let cost-of-heading abs heading-difference / 360
  ;  ;print cost-of-heading
  ;
  ;  ifelse ( total-cost >= cost-of-heading ) [
  ;    set heading [heading] of target
  ;  ][
  ;    set heading heading + 360 * total-cost * -1 * ( heading-difference / abs heading-difference )
  ;  ]
  ;print heading
  ;print ""


  if (target != nobody ) [

    ; deteremine x and y coordinate difference to target
    let ycor-difference [ y.magnitude ] of target
    let xcor-difference [ x.magnitude ] of target

    if ( not ( ycor-difference = 0 and xcor-difference = 0 ) ) [ ; If the target isn't in the exact same location as self

      ; calculate angle to target
      let angle atan xcor-difference ycor-difference
      if ( cost < 0 ) [ set angle angle - 180 ]

      ; set magnitudes based on cost
      set x.magnitude x.magnitude + (abs cost * sin angle)
      set y.magnitude y.magnitude + (abs cost * cos angle) ]

    ; set heading based on magnitudes
    set heading ifelse-value ( x.magnitude = 0 and y.magnitude = 0 ) [ heading ] [ ( atan x.magnitude y.magnitude ) ]
  ]

end


  
  ;-------------------------------------------------------------------------------------------------
  ; SPOT CHECK FUNCTIONS
  ;-------------------------------------------------------------------------------------------------
  
to reset-chromosomes
  ;  if ( mother != nobody and father != nobody ) [
  ;    ask mother [ 
  ;      set chromosome.I [ [ true "A" "B" "C" ] [ true "D" "E" "F" ] [ true "G" "H" "I" ] [ true "X" "Y" "Z" ] [ true "E" 0.1 0.2 0.3 ]] 
  ;      set chromosome.II [ [ true "A2" "B2" "C2" ] [ true "D2" "E2" "F2" ] [ true "G2" "H2" "I2" ] ] 
  ;    ]
  ;    ask father [ 
  ;      set chromosome.I [ [ true "J" "K" "L" ] [ true "M" "N" "O" ] [ true "P" "Q" "R" ] ] 
  ;      set chromosome.II [ [ true "J2" "K2" "L2" ] [ true "M2" "N2" "O2" ] [ true "P2" "Q2" "R2" ]  ] 
  ;    ]
  ;    setup-chromosomes-from mother father
  ;  ]
end

  
;--------------------------------------------------------------------------------------------------------------------
;
; PARAMETER SPACE SWEEPING FOR RSN BEST FIT
;
;--------------------------------------------------------------------------------------------------------------------

to-report calculate-lotka-volterra
  
  let N1a first plant-abundance-record
  let N2a first population-size-record
  
  let bestparam []
  let gmax 0
  
  let N1r1  500
  let N1r2  1500
  let N2r1  25
  let N2r2  45
  let r1r1   0.1
  let r1r2   0.9
  let r2r1  -0.9
  let r2r2  -0.1
  let s12r1 -0.1
  let s12r2 -0.001
  let s21r1 0.0001
  let s21r2 0.002
  let steps 10
  
  let N1w N1r1 - (N1r2 - N1r1) / steps
  while [ N1w < N1r2 + (N1r2 - N1r1) / steps / 2 ]
  [ Set N1w N1w + (N1r2 - N1r1) / steps
    
    let N2w N2r1 - (N2r2 - N2r1) / steps
    while [ N2w < N2r2 + (N2r2 - N2r1) / steps / 2 ]
    [ Set N2w N2w + (N2r2 - N2r1) / steps
      
      let r1w r1r1 - (r1r2 - r1r1) / steps
      while [ r1w < r1r2 + (r1r2 - r1r1) / steps / 2 ]
      [ Set r1w r1w + (r1r2 - r1r1) / steps
        
        let r2w r2r1 - (r2r2 - r2r1) / steps
        while [ r2w < r2r2 + (r2r2 - r2r1) / steps / 2 ]
        [ Set r2w r2w + (r2r2 - r2r1) / steps
          
          let s12w s12r1 - (s12r2 - s12r1) / steps
          while [ s12w < s12r2 + (s12r2 - s12r1)/ steps / 2 ]
          [ Set s12w s12w + (s12r2 - s12r1)/ steps
            
            let s21w s21r1 - (s21r2 - s21r1) / steps
            while [ s21w < s21r2 + (s21r2 - s21r1)/ steps / 2 ]
            [ Set s21w s21w + (s21r2 - s21r1)/ steps
              
              let results rsn r1w r2w 0 s12w s21w 0 N1w N2w ; Simulate the rsN equations.
              let N1s first results
              let N2s last  results
              
              let g1 fit N1a N1s                            ; Calculate goodness of fit for
              let g2 fit N2a N2s                            ; both curves.
              
              let g ( g1 + g2 ) / 2                            ; Report the results.
              if  ( g > gmax )
              [ set bestparam ( list g r1w r2w s12w s21w N1w N2w )
                set gmax g ]
              
  ] ] ] ] ] ]
  
  ;....display the best result....
  report bestparam
  
end

;--------------------------------------------------------------------------------------------------------------------
;
; SUBROUTINE TO SIMULATE RSN DIFFERENTIAL EQUATION
;
; This routine simulates two ecological populations growing according
; to the <m>rsN</m> equations,
;   <M> {1\over N_1}\,{dN_1\over dt} = r_1 +s_{1,1}N_1 +s_{1,2}N_2 </M>
;   <M> {1\over N_2}\,{dN_2\over dt} = r_2 +s_{2,1}N_1 +s_{2,2}N_2 </M>
;
; It uses the Euler method<https://en.wikipedia.org/wiki/Euler_method/> to solve
; the differential equations numerically. The time step <v>dt</v> should be made
; small enough so that further decreases in its value do not significantly change
; the solution.
;
; Any parameters may be supplied below to represent variations of competition,
; predation, mutualism, or other two-species interactions such as commensalism.
;
; ENTRY: 'r1'  and 'r2' contain the intrinsic growth rates for each species.
;        's11' and 's22' ('sii') contain the self-limitation or enhancement terms
;         for each species.
;        's12' and 's21' ('sij') contain the cross-coupling terms for species for
;          the limiting or enhancement of the growth of species 'i' by species 'j'.
;        'N1i' and 'N2i' contain the starting values for each species.
;
; EXIT:  'N1s' and 'N2s' contain the simulated results, yearly for 40 years.
;         (The ending time should be a parameter.)
;
;--------------------------------------------------------------------------------------------------------------------
  
to-report rsn [r1 r2 s11 s12 s21 s22 N1i N2i ]
  ;  let r1 1
  ;  let r2 1
  ;  let s11 -1 ; throw out?
  ;  let s12 -.5
  ;  let s21 1
  ;  let s22 -1 ; throw out?
  ;  let N1 0.4
  ;  let N2 0.1
  
  Let N1 N1i                                                        ; Set the initial conditions.
  Let N2 N2i
  
  Let dt 1 / 365                                                    ; Set the time step.
  
  Let N1s []                                                        ; Establish the output lists.
  Let N2s []
  
  let y -1                                                          ; Loop through all years.
  while [ y < 40 ]
  [
    Set y y + 1                                                     ; Add the present population values
    Set N1s lput N1 N1s                                             ; to the end of the respective lists.
    Set N2s lput N2 N2s
    
    let t ( 0 - dt )                                                ; Step day by day through the year,
    while [ t < ( 1 + dt / 2 ) ]                                    ; calculating but not recording
    [ Set t t + dt                                                  ; the intermediate results.
      Let dN1 ( r1 + s11 * N1 + s12 * N2 ) * N1 * dt
      Let dN2 ( r2 + s21 * N1 + s22 * N2 ) * N2 * dt
      Set N1 N1 + dN1
      Set N2 N2 + dN2
      if ( N1 < 0 ) [ Set N1 0 ]
      if ( N2 < 0 ) [ Set N2 0 ] ] ]
  
  report ( list N1s N2s )                                          ; Return the simulated results.
  
end

;--------------------------------------------------------------------------------------------------------------------
;
; SUBROUTINE TO CALCULATE GOODNESS OF FIT                  
;
; This routine accepts a set of data containing observations and predictions,
; and computes how well the predictions match the observations. Various
; measures of how well they match could be calculated in this routine, such as
; with least-squares, least absolute value, or other measures. The goodness of
; fit is presented in the form of
; <m>R^2</m>.<https://en.wikipedia.org/wiki/Coefficient_of_determination/>
;
; That is, it is presented as <m>1-F/E</m>, where
; <m>F</m> is the summed deviations of the observations from the predictions, and
; <m>E</m> is the summed deviations of the observations from the expected value
; (mean) of the observations, assuming there were no functional relationship.
;
; ENTRY: 'k' specifies the number of actual values there are.
;        'S' contains the estimated values from the simulated curve, indexed by
;         time, starting with time 0.
;        'A' contains the actual measured values, indexed arbitrarily from 1 to
;         'k'.
;        'y' defines the time index for each corresponding value in 'A', also
;         indexed arbitrarily from 1 to 'k'
;
; EXIT:  'g' contains the goodness of fit measure for that data.
;
;--------------------------------------------------------------------------------------------------------------------

to-report fit [ A S ]
  
  let mu mean A                                         ; Compute the mean of the data.
  
  let total 0                                           ; Prepare variables for loop.
  let residual 0
  let k length A
  let i 0
  
  while [ i < k ]
  [ set i i + 1                                         ; Compute the total squared
    Set residual residual + ( item i A - item i S ) ^ 2 ; deviations of the actual data
    Set total total + ( item i A - mu ) ^ 2             ; from the function and from the
  ]                                                     ; mean.
  
  report 1 - residual / total                           ; Return the goodness-of-fit.
  
end



; NOTE FOR CL: if     (..condition..) [..truepart..]
;              ifelse (..condition..) [..truepart..] [..falsepart..]


;    lotka-volterra-best-fit
;    lotka-volterra-r1
;    lotka-volterra-r2
;    lotka-volterra-s12
;    lotka-volterra-s21
;    lotka-volterra-N1
;    lotka-volterra-N2
;    
;    optimal-foraging-regression-constant
;    optimal-foraging-regression-coeff
;    optimal-foraging-r-squared
;    optimal-foraging-adj-r-squared
;    optimal-foraging-F-statistic
;    optimal-foraging-probability-of-F
;    optimal-foraging-standard-error
;    optimal-foraging-tot-degrees-of-freedom
;    optimal-foraging-reg-degrees-of-freedom
;    optimal-foraging-err-degrees-of-freedom
;    optimal-foraging-tot-sum-of-squares
;    optimal-foraging-reg-sum-of-squares
;    optimal-foraging-err-sum-of-squares
;    
;    mother-initiated-birth-regression-constant
;    mother-initiated-birth-regression-coeff
;    mother-initiated-birth-r-squared
;    mother-initiated-birth-adj-r-squared
;    mother-initiated-birth-F-statistic
;    mother-initiated-birth-probability-of-F
;    mother-initiated-birth-standard-error
;    mother-initiated-birth-tot-degrees-of-freedom
;    mother-initiated-birth-reg-degrees-of-freedom
;    mother-initiated-birth-err-degrees-of-freedom
;    mother-initiated-birth-tot-sum-of-squares
;    mother-initiated-birth-reg-sum-of-squares
;    mother-initiated-birth-err-sum-of-squares
;    
;    mother-initiated-wean-regression-constant
;    mother-initiated-wean-regression-coeff
;    mother-initiated-wean-r-squared
;    mother-initiated-wean-adj-r-squared
;    mother-initiated-wean-F-statistic
;    mother-initiated-wean-probability-of-F
;    mother-initiated-wean-standard-error
;    mother-initiated-wean-tot-degrees-of-freedom
;    mother-initiated-wean-reg-degrees-of-freedom
;    mother-initiated-wean-err-degrees-of-freedom
;    mother-initiated-wean-tot-sum-of-squares
;    mother-initiated-wean-reg-sum-of-squares
;    mother-initiated-wean-err-sum-of-squares
;    
;    hamiltons-rule-regression-constant
;    hamiltons-rule-regression-coeff
;    hamiltons-rule-r-squared
;    hamiltons-rule-adj-r-squared
;    hamiltons-rule-F-statistic
;    hamiltons-rule-probability-of-F
;    hamiltons-rule-standard-error
;    hamiltons-rule-tot-degrees-of-freedom
;    hamiltons-rule-reg-degrees-of-freedom
;    hamiltons-rule-err-degrees-of-freedom
;    hamiltons-rule-tot-sum-of-squares
;    hamiltons-rule-reg-sum-of-squares
;    hamiltons-rule-err-sum-of-squares
    
;      
;      "lotka-volterra-best-fit"
;      "lotka-volterra-r1"
;      "lotka-volterra-r2"
;      "lotka-volterra-s12"
;      "lotka-volterra-s21"
;      "lotka-volterra-N1"
;      "lotka-volterra-N2"
;      
;      "optimal-foraging-regression-constant"
;      "optimal-foraging-regression-coeff"
;      "optimal-foraging-r-squared"
;      "optimal-foraging-adj-r-squared"
;      "optimal-foraging-F-statistic"
;      "optimal-foraging-probability-of-F"
;      "optimal-foraging-standard-error"
;      "optimal-foraging-tot-degrees-of-freedom"
;      "optimal-foraging-reg-degrees-of-freedom"
;      "optimal-foraging-err-degrees-of-freedom"
;      "optimal-foraging-tot-sum-of-squares"
;      "optimal-foraging-reg-sum-of-squares"
;      "optimal-foraging-err-sum-of-squares"
;      
;      "mother-initiated-birth-regression-constant"
;      "mother-initiated-birth-regression-coeff"
;      "mother-initiated-birth-r-squared"
;      "mother-initiated-birth-adj-r-squared"
;      "mother-initiated-birth-F-statistic"
;      "mother-initiated-birth-probability-of-F"
;      "mother-initiated-birth-standard-error"
;      "mother-initiated-birth-tot-degrees-of-freedom"
;      "mother-initiated-birth-reg-degrees-of-freedom"
;      "mother-initiated-birth-err-degrees-of-freedom"
;      "mother-initiated-birth-tot-sum-of-squares"
;      "mother-initiated-birth-reg-sum-of-squares"
;      "mother-initiated-birth-err-sum-of-squares"
;      
;      "mother-initiated-wean-regression-constant"
;      "mother-initiated-wean-regression-coeff"
;      "mother-initiated-wean-r-squared"
;      "mother-initiated-wean-adj-r-squared"
;      "mother-initiated-wean-F-statistic"
;      "mother-initiated-wean-probability-of-F"
;      "mother-initiated-wean-standard-error"
;      "mother-initiated-wean-tot-degrees-of-freedom"
;      "mother-initiated-wean-reg-degrees-of-freedom"
;      "mother-initiated-wean-err-degrees-of-freedom"
;      "mother-initiated-wean-tot-sum-of-squares"
;      "mother-initiated-wean-reg-sum-of-squares"
;      "mother-initiated-wean-err-sum-of-squares"
;      
;      "hamiltons-rule-regression-constant"
;      "hamiltons-rule-regression-coeff"
;      "hamiltons-rule-r-squared"
;      "hamiltons-rule-adj-r-squared"
;      "hamiltons-rule-F-statistic"
;      "hamiltons-rule-probability-of-F"
;      "hamiltons-rule-standard-error"
;      "hamiltons-rule-tot-degrees-of-freedom"
;      "hamiltons-rule-reg-degrees-of-freedom"
;      "hamiltons-rule-err-degrees-of-freedom"
;      "hamiltons-rule-tot-sum-of-squares"
;      "hamiltons-rule-reg-sum-of-squares"
;      "hamiltons-rule-err-sum-of-squares"
      
      
;  ; STATISTICAL CALCULATIONS
;  
;  ; lotka volterra
;  let lotka-volterra-results (list 0 0 0 0 0 0 0 ) ; calculate-lotka-volterra
;  let lotka-volterra-best-fit item 0 lotka-volterra-results
;  let lotka-volterra-r1 item 1 lotka-volterra-results
;  let lotka-volterra-r2 item 2 lotka-volterra-results
;  let lotka-volterra-s12 item 3 lotka-volterra-results
;  let lotka-volterra-s21 item 4 lotka-volterra-results
;  let lotka-volterra-N1 item 5 lotka-volterra-results
;  let lotka-volterra-N2 item 6 lotka-volterra-results
;  
;  ; stats table with generation number in first column as dependent variable
;  ;let generation-table stats:newtable
;  ;stats:set-names generation-table ( list "generation-number" "optimal-foraging-index"  "mother-initiated-birth-percent" "mother-initiated-wean-percent" "hamiltons-rule-percent" )
;  
;  let stop-generation 10
;  let g 1
;  
;  while [ g < stop-generation ] [
;    
;    let sum-foraging-gains sum [foraging.gains] of anima1s with [ generation.number = g ]
;    let sum-energy-cost sum [total.energy.cost] of anima1s with [ generation.number = g ]
;    let generation-size count anima1s with [ generation.number = g ]
;    
;    let optimal-foraging-index ifelse-value ( sum-energy-cost > 0 ) [ sum-foraging-gains / sum-energy-cost ] [ 0 ]
;    let mother-initiated-birth-percent ifelse-value ( generation-size > 0 ) [ count anima1s with [ generation.number = g and mother.initiated.birth ] / generation-size ] [ 0 ]
;    let mother-initiated-wean-percent ifelse-value ( generation-size > 0 ) [ count anima1s with [ generation.number = g and mother.initiated.weaning ] / generation-size ] [ 0 ]
;    let hamiltons-rule-percent ifelse-value ( generation-size > 0 ) [ count anima1s with [ whole.related.help.cost > half.related.help.cost and half.related.help.cost > fourth.related.help.cost and fourth.related.help.cost > eighth.related.help.cost and generation.number = g ] / generation-size ] [ 0 ]
;    
;    ;stats:add generation-table ( list g optimal-foraging-index mother-initiated-birth-percent mother-initiated-wean-percent hamiltons-rule-percent )
;    
;    set g g + 1 ]
;
;  ; calculate correlations
;  let correlation-matrix 0 ;stats:correlation generation-table
;  
;  ; optimal foraging
;  let optimal-foraging-correlation 0 ;item 0 item 1 correlation-matrix
;  let optimal-foraging-regression-coeffs 0 ;stats:regress-on generation-table [ "generation-number" "optimal-foraging-index" ]
;  let optimal-foraging-regression-constant 0;first optimal-foraging-regression-coeffs
;  let optimal-foraging-regression-coeff 0 ;last optimal-foraging-regression-coeffs
;  let regression-stats 0 ;stats:get-rstats generation-table
;  let optimal-foraging-r-squared 0 ;item 0 regression-stats
;  let optimal-foraging-adj-r-squared 0 ;item 1 regression-stats
;  let optimal-foraging-F-statistic 0 ;item 2 regression-stats
;  let optimal-foraging-probability-of-F 0 ;item 3 regression-stats
;  let optimal-foraging-standard-error 0 ;item 4 regression-stats
;  let optimal-foraging-tot-degrees-of-freedom 0 ;item 5 regression-stats
;  let optimal-foraging-reg-degrees-of-freedom 0 ;item 6 regression-stats
;  let optimal-foraging-err-degrees-of-freedom 0 ;item 7 regression-stats
;  let optimal-foraging-tot-sum-of-squares 0 ;item 8 regression-stats
;  let optimal-foraging-reg-sum-of-squares 0 ;item 9 regression-stats
;  let optimal-foraging-err-sum-of-squares 0 ;item 10 regression-stats
;  
;  ; parent-offspring conflict at birth
;  let mother-initiated-birth-correlation 0 ;item 0 item 2 correlation-matrix
;  let mother-initiated-birth-regression-coeffs 0 ;stats:regress-on generation-table [ "generation-number" "mother-initiated-birth-percent" ]
;  let mother-initiated-birth-regression-constant 0 ;first mother-initiated-birth-regression-coeffs
;  let mother-initiated-birth-regression-coeff 0 ;last mother-initiated-birth-regression-coeffs
;  set regression-stats 0 ;stats:get-rstats 0 ;generation-table
;  let mother-initiated-birth-r-squared 0 ;item 0 regression-stats
;  let mother-initiated-birth-adj-r-squared 0 ;item 1 regression-stats
;  let mother-initiated-birth-F-statistic 0 ;item 2 regression-stats
;  let mother-initiated-birth-probability-of-F 0 ;item 3 regression-stats
;  let mother-initiated-birth-standard-error 0 ;item 4 regression-stats
;  let mother-initiated-birth-tot-degrees-of-freedom 0 ;item 5 regression-stats
;  let mother-initiated-birth-reg-degrees-of-freedom 0 ;item 6 regression-stats
;  let mother-initiated-birth-err-degrees-of-freedom 0 ;item 7 regression-stats
;  let mother-initiated-birth-tot-sum-of-squares 0 ;item 8 regression-stats
;  let mother-initiated-birth-reg-sum-of-squares 0 ;item 9 regression-stats
;  let mother-initiated-birth-err-sum-of-squares 0 ;item 10 regression-stats
;  
;  ; parent-offspring conflict at weaning
;  let mother-initiated-wean-correlation 0 ;item 0 item 3 correlation-matrix
;  let mother-initiated-wean-regression-coeffs 0 ;stats:regress-on generation-table [ "generation-number" "mother-initiated-wean-percent" ]
;  let mother-initiated-wean-regression-constant 0 ;first mother-initiated-wean-regression-coeffs
;  let mother-initiated-wean-regression-coeff 0 ;last mother-initiated-wean-regression-coeffs
;  set regression-stats 0 ;stats:get-rstats generation-table
;  let mother-initiated-wean-r-squared 0 ;item 0 regression-stats
;  let mother-initiated-wean-adj-r-squared 0 ;item 1 regression-stats
;  let mother-initiated-wean-F-statistic 0 ;item 2 regression-stats
;  let mother-initiated-wean-probability-of-F 0 ;item 3 regression-stats
;  let mother-initiated-wean-standard-error 0 ;item 4 regression-stats
;  let mother-initiated-wean-tot-degrees-of-freedom 0 ;item 5 regression-stats
;  let mother-initiated-wean-reg-degrees-of-freedom 0 ;item 6 regression-stats
;  let mother-initiated-wean-err-degrees-of-freedom 0 ;item 7 regression-stats
;  let mother-initiated-wean-tot-sum-of-squares 0 ;item 8 regression-stats
;  let mother-initiated-wean-reg-sum-of-squares 0 ;item 9 regression-stats
;  let mother-initiated-wean-err-sum-of-squares 0 ;item 10 regression-stats
; 
;  ; hamilton's rule
;  let hamiltons-rule-correlation 0 ;item 0 item 4 correlation-matrix
;  let hamiltons-rule-regression-coeffs 0; stats:regress-on generation-table [ "generation-number" "hamiltons-rule-percent" ]
;  let hamiltons-rule-regression-constant 0;  first hamiltons-rule-regression-coeffs
;  let hamiltons-rule-regression-coeff 0;  last hamiltons-rule-regression-coeffs
;  set regression-stats 0;  stats:get-rstats generation-table
;  let hamiltons-rule-r-squared 0;  item 0 regression-stats
;  let hamiltons-rule-adj-r-squared 0;  item 1 regression-stats
;  let hamiltons-rule-F-statistic 0;  item 2 regression-stats
;  let hamiltons-rule-probability-of-F 0;  item 3 regression-stats
;  let hamiltons-rule-standard-error  0; item 4 regression-stats
;  let hamiltons-rule-tot-degrees-of-freedom 0;  item 5 regression-stats
;  let hamiltons-rule-reg-degrees-of-freedom 0;  item 6 regression-stats
;  let hamiltons-rule-err-degrees-of-freedom 0;  item 7 regression-stats
;  let hamiltons-rule-tot-sum-of-squares 0;  item 8 regression-stats
;  let hamiltons-rule-reg-sum-of-squares 0;  item 9 regression-stats
;  let hamiltons-rule-err-sum-of-squares 0;  item 10 regression-stats
  

;to-report max-proximity [ target ] ; the max distance between two individuals (based on their body size - bigger individuals are in proximity from farther away)
;  ; distance measured between centers of bodies
;  report ( size / 2 + ( ifelse-value ( is-patch? target ) [ 1 ] [[size] of target / 2 ]))
;end

to attack-victims 
  ask anima1s with [ member? [my.identity] of myself attack.from.history ] [
    inspect self 
  ]
end



;to reduce-to-unique-vectors
;
;  let initial-decisions decision.vectors
;  let reduced-decisions []
;
;  foreach initial-decisions [ original-vector ->
;    let original-ego item 0 original-vector
;    let original-target item 1 original-vector
;    let original-action item 2 original-vector
;    let original-weight item 3 original-vector
;    let vector-doesnt-exist true
;
;    let index 0
;    foreach reduced-decisions [ reduced-vector ->
;      let reduced-ego item 0 reduced-vector
;      let reduced-target item 1 reduced-vector
;      let reduced-action item 2 reduced-vector
;      let reduced-weight item 3 reduced-vector
;
;      if ( reduced-ego = original-ego ) and ( reduced-target = original-target ) and ( reduced-action = original-action ) [
;        set vector-doesnt-exist false
;        set reduced-weight ifelse-value ( is-number? reduced-weight ) [ reduced-weight ] [ 0 ]
;        set original-weight ifelse-value ( is-number? original-weight ) [ original-weight ] [ 0 ]
;        let new-vector ( list self reduced-target reduced-action ( reduced-weight + original-weight ) false )
;        set reduced-decisions remove-item index reduced-decisions
;        set reduced-decisions lput new-vector reduced-decisions ]
;      set index index + 1
;    ]
;    if vector-doesnt-exist [ set reduced-decisions lput ( list self original-target original-action original-weight false ) reduced-decisions ]
;  ]
;  set decision.vectors reduced-decisions
;end


;to get-decision [ g ]
;  let my-environment my.environment
;  let ego-status status-of self
;  if ( length g = 5 and is-string? item 1 g and is-string? item 2 g and is-string? item 3 g and is-number? item 4 g ) [ ; checks that allele correctly organized
;    let gene-ego item 1 g
;    let gene-other item 2 g
;    let gene-action item 3 g
;    let gene-weight item 4 g
;    
;    ; Check that first CODON matches self
;    if first-string-is-part-of-last? ( gene-ego ) ( ego-status ) [
;      
;      ; Consider status-of others in the environment
;      foreach my-environment [ other-guy ->
;        let other-status status-of other-guy 
;        
;        ; Check that second CODON matches other
;        if first-string-is-part-of-last? ( gene-other ) ( other-status ) [
;          
;          let distance-to-target distance other-guy
;          set distance-to-target ifelse-value ( distance-to-target > 1 ) [ distance-to-target ] [ 1 ]
;          print (list self other-guy ( sta7us-get-action gene-action ) precision ( gene-weight / ( distance-to-target ^ 2 )) 10 false ) 
;          
;        ]
;      ]
;    ]
;  ]  
;end
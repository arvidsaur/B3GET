;----------------------------------------------------------------------------------------------
;
;        dP            dP            
;        88            88            
;  .d888b88 .d8888b. d8888P .d8888b. 
;  88'  `88 88'  `88   88   88'  `88 
;  88.  .88 88.  .88   88   88.  .88 
;  `88888P8 `88888P8   dP   `88888P8 
;
; Â© 2021 K N Crouse  
;
; This extension contains all subroutines that allow users to create population and genotype 
; files and store metadata from a simulation. These files are all stored in the data folder.
;
;----------------------------------------------------------------------------------------------


to-report generate-genotype-id
  report ( word "g" generate-timestamp )
end

to-report generate-population-id
  report ( word "p" generate-timestamp )
end


;----------------------------------------------------------------------------------------------
;
; CREATE OR UPDATE METAFILE WHEN USER INTERACTS WITH B3GET
;
; This subroutine serves to keep a record of user interface interactions, which include
; importing and exporting population and genotype files, and some button clicks and commands.
; Each interaction is saved as a new row within the "metafile.csv" file and each column records
; information of interest regarding that interaction, such as the name of the current simulation,
; the type of interaction currently underway, and current parameter settings. This information
; is located in B3GET > data > metafile.csv.
;
; ENTRY:
;
; EXIT: 
; 
;----------------------------------------------------------------------------------------------

to update-metafile [ type-of-file name-of-file metafile-notes ]
  
  set observation-notes metafile-notes
  
  let filename "../results/metafile.csv"
  
  ; Save whatever is currently in the METAFILE or create new
  if ( not file-exists? filename ) 
  
  [ 
    file-open "../data/metafile.csv"
    csv:to-file "../data/metafile.csv" (list (list
      "date-and-time"
      "path-to-experiment"
      "model-version"
      "model-structure"
      "genotype-reader"
      "simulation-id"
      "ticks"
      "file-type"
      "file-name"
      "observation-notes"
      "population-input" 
      "genotype-input"
      "plant-annual-cycle" 
      "plant-seasonality" 
      "plant-minimum-neighbors" 
      "plant-maximum-neighbors" 
      "plant-daily-cycle" 
      "plant-quality"
      "world-width" 
      "world-height"
      "deterioration-rate" 
      "output-results?" 
      "selection-on?"
      "useful-commands"
    ))
  ]
  
  file-open filename
  
  if observation-notes = "" [ set observation-notes "Metafile updated." ]
  
  ; Update METAFILE with a new row of FILE information
  file-print csv:to-string (list
    (list 
      date-and-time
      path-to-experiment
      model-version
      model-structure
      genotype-reader
      simulation-id
      ticks
      type-of-file
      name-of-file
      observation-notes
      population 
      genotype
      plant-annual-cycle 
      plant-seasonality
      plant-minimum-neighbors 
      plant-maximum-neighbors
      plant-daily-cycle 
      plant-quality
      world-width 
      world-height
      deterioration-rate
      output-results?
      selection-on?
      useful-commands
  ))
  
  set observation-notes ""
  file-close
  
end

;----------------------------------------------------------------------------------------------
;
; CREATE A SET OF AGENTS FROM INFORMATION STORED IN A POPULATION FILE
; 
; This subroutine creates a new set of agents and for each agent sets their attributes according
; to the values stored in a csv population file. Each row in the file stores the unique attribute
; settings for one agent and each column represents one kind of attribute that each member in the
; population has.
;
; ENTRY: PATH-TO-EXPERIMENT
;        POPULATION
;
; EXIT: SET OF AGENTS WHOSE COMPOSITION AND ATTRBUUTES MATCH THOSE IN THE population file
;
;----------------------------------------------------------------------------------------------

to import-population
  
  let file-to-import ( word path-to-experiment population ".csv" ) ; first try accessing file in designated file path
  if not file-exists? file-to-import [ set file-to-import ( word "../data/" population ".csv" ) ] ; then try the data folder
  
  ifelse  ( is-string? file-to-import and file-exists? file-to-import ) [ ; check both locations
    
    file-open file-to-import
    let data-from-filename csv:from-file file-to-import
    file-close 
    
    let header-block first data-from-filename ; Header information from FILE-TO-IMPORT
    let data-block but-first data-from-filename ; FILE-TO-IMPORT data without header information
    
    let i 0 ; index variable to iteratively search through each row in the DATA-BLOCK
    let j 0 ; index variable to iteratively search through each header in the HEADER-BLOCK
    
    ; FOR EACH row in the DATA-BLOCK create a generic turtle
    foreach data-block [ row -> 
      create-turtles 1 [
        set j 0
        
        ; FOR EACH header in the HEADER-BLOCK set turtle's state variables to the corresponding values
        foreach header-block [ header ->
          let value item j item i data-block ; the value for turtle i taken from column j of the DATA-BLOCK

          (ifelse ; If file header and agent breed requirements are met, set state variable according to value
            
            ( header = "breed" ) [ set breed run-result value ]
            ( header = "color" ) [ set color value ]
            ( header = "heading" ) [ set heading value ]	
            ( header = "xcor" ) [ set xcor value ]	
            ( header = "ycor" ) [ set ycor value ]	
            ( header = "label" ) [ set label value ]	
            ( header = "label-color" ) [ set label-color value ]	
            ( header = "hidden?" ) [ set hidden? value ]
            ( header = "size" ) [ set size value ]	
            ( header = "pen-size" ) [ set pen-size value ]	
            ( header = "pen-mode" ) [ set pen-mode value ]            
            
            ( breed = anima1s and header = "meta.id" ) [ set meta.id value ]
            ( breed = anima1s and header = "biological.sex" ) [ set biological.sex value ]
            ( breed = anima1s and header = "life.history" ) [ set life.history value ]
            ( breed = anima1s and header = "female.fertility" ) [ set female.fertility value ]
            ( breed = anima1s and header = "group.identity" ) [ set group.identity value ]
            ( breed = anima1s and header = "is.alive" ) [ set is.alive value ]
            ( breed = anima1s and header = "yellow.signal" ) [ set yellow.signal value ]
            ( breed = anima1s and header = "red.signal" ) [ set red.signal value ]
            ( breed = anima1s and header = "blue.signal" ) [ set blue.signal value ]
            ( breed = anima1s and header = "body.size" ) [ set body.size value ]
            ( breed = anima1s and header = "body.shade" ) [ set body.shade value ]
            ( breed = anima1s and header = "is.resting" ) [ set is.resting value ]
            ( breed = anima1s and header = "identity.I" ) [ set identity.I value ]
            ( breed = anima1s and header = "identity.II" ) [ set identity.II value ]
            ( breed = anima1s and header = "carried.items" ) [ set carried.items value ]
            ( breed = anima1s and header = "hidden.chance" ) [ set hidden.chance value ]
            ( breed = anima1s and header = "fully.decayed" ) [ set fully.decayed value ]
            ( breed = anima1s and ( header = "living.chance" or header = "survival.chance" ) ) [ set survival.chance value ]
            ( breed = anima1s and header = "energy.supply" ) [ set energy.supply value ]
            ( breed = anima1s and header = "bite.capacity" ) [ set bite.capacity value ]
            ( breed = anima1s and header = "mutation.chance" ) [ set mutation.chance value ]
            ( breed = anima1s and header = "sex.ratio" ) [ set sex.ratio value ]
            ( breed = anima1s and header = "litter.size" ) [ set litter.size value ]
            ( breed = anima1s and header = "conception.chance" ) [ set conception.chance value ]
            ( breed = anima1s and header = "visual.angle" ) [ set visual.angle value ]
            ( breed = anima1s and header = "visual.range" ) [ set visual.range value ]
            ( breed = anima1s and header = "day.perception" ) [ set day.perception value ]
            ( breed = anima1s and header = "night.perception" ) [ set night.perception value ]
            ( breed = anima1s and header = "yellow.chance" ) [ set yellow.chance value ]
            ( breed = anima1s and header = "red.chance" ) [ set red.chance value ]
            ( breed = anima1s and header = "blue.chance" ) [ set blue.chance value ]
            ( breed = anima1s and header = "birthing.chance" ) [ set birthing.chance value ]
            ( breed = anima1s and header = "weaning.chance" ) [ set weaning.chance value ]
            ( breed = anima1s and header = "infancy.chance" ) [ set infancy.chance value ]
            ( breed = anima1s and header = "juvenility.chance" ) [ set juvenility.chance value ]
            ( breed = anima1s and header = "adulthood.chance" ) [ set adulthood.chance value ]
            ( breed = anima1s and header = "x.magnitude" ) [ set x.magnitude value ]
            ( breed = anima1s and header = "y.magnitude" ) [ set y.magnitude value ]
            ( breed = anima1s and header = "chromosome.I" ) [ set chromosome.I csv:from-string value ]
            ( breed = anima1s and header = "chromosome.II" ) [ set chromosome.II csv:from-string value ]
            ( breed = anima1s and header = "my.environment" ) [ set my.environment value ]
            ( breed = anima1s and header = "decision.vectors" ) [ set decision.vectors value ]
            ( breed = anima1s and header = "actions.completed" ) [ set actions.completed value ]
            ( breed = anima1s and header = "age.in.ticks" ) [ set age.in.ticks value ]
            ( breed = anima1s and header = "generation.number" ) [ set generation.number value ]
            ( breed = anima1s and header = "my.mother" ) [ set my.mother value ]
            ( breed = anima1s and header = "mother.identity" ) [ set mother.identity value ]
            ( breed = anima1s and header = "father.identity" ) [ set father.identity value ]
            ( breed = anima1s and header = "natal.group.id" ) [ set natal.group.id value ]
            ( breed = anima1s and header = "natal.group.size" ) [ set natal.group.size value ]
            ( breed = anima1s and header = "death.group.id" ) [ set death.group.id value ]
            ( breed = anima1s and header = "death.group.size" ) [ set death.group.size value ]
            ( breed = anima1s and header = "ticks.at.conception" ) [ set ticks.at.conception value ]
            ( breed = anima1s and header = "ticks.at.birth" ) [ set ticks.at.birth value ]
            ( breed = anima1s and header = "ticks.at.weaning" ) [ set ticks.at.weaning value ]
            ( breed = anima1s and header = "ticks.at.sexual.maturity" ) [ set ticks.at.sexual.maturity value ]
            ( breed = anima1s and header = "ticks.at.death" ) [ set ticks.at.death value ]
            ( breed = anima1s and header = "adult.hidden.chance" ) [ set adult.hidden.chance value ]
            ( breed = anima1s and ( header = "adult.living.chance" or header = "adult.survival.chance" ) ) [ set adult.survival.chance value ]
            ( breed = anima1s and header = "adult.body.size" ) [ set adult.body.size value ]
            ( breed = anima1s and header = "adult.body.shade" ) [ set adult.body.shade value ]
            ( breed = anima1s and header = "adult.energy.supply" ) [ set adult.energy.supply value ]
            ( breed = anima1s and header = "adult.bite.capacity" ) [ set adult.bite.capacity value ]
            ( breed = anima1s and header = "adult.mutation.chance" ) [ set adult.mutation.chance value ]
            ( breed = anima1s and header = "adult.sex.ratio" ) [ set adult.sex.ratio value ]
            ( breed = anima1s and header = "adult.litter.size" ) [ set adult.litter.size value ]
            ( breed = anima1s and header = "adult.conception.chance" ) [ set adult.conception.chance value ]
            ( breed = anima1s and header = "adult.visual.angle" ) [ set adult.visual.angle value ]
            ( breed = anima1s and header = "adult.visual.range" ) [ set adult.visual.range value ]
            ( breed = anima1s and header = "adult.day.perception" ) [ set adult.day.perception value ]
            ( breed = anima1s and header = "adult.night.perception" ) [ set adult.night.perception value ]
            ( breed = anima1s and header = "adult.yellow.chance" ) [ set adult.yellow.chance value ]
            ( breed = anima1s and header = "adult.red.chance" ) [ set adult.red.chance value ]
            ( breed = anima1s and header = "adult.blue.chance" ) [ set adult.blue.chance value ]
            ( breed = anima1s and header = "distance.traveled" ) [ set distance.traveled value ]
            ( breed = anima1s and header = "cells.occupied" ) [ set cells.occupied value ]
            ( breed = anima1s and header = "mother.initiated.birth" ) [ set mother.initiated.birth value ]
            ( breed = anima1s and header = "mother.initiated.weaning" ) [ set mother.initiated.weaning value ]
            ( breed = anima1s and header = "whole.related.help.cost" ) [ set whole.related.help.cost value ]
            ( breed = anima1s and header = "half.related.help.cost" ) [ set half.related.help.cost value ]
            ( breed = anima1s and header = "fourth.related.help.cost" ) [ set fourth.related.help.cost value ]
            ( breed = anima1s and header = "eighth.related.help.cost" ) [ set eighth.related.help.cost value ]
            ( breed = anima1s and header = "foraging.gains" ) [ set foraging.gains value ]
            ( breed = anima1s and header = "total.energy.gains" ) [ set total.energy.gains value ]
            ( breed = anima1s and header = "total.energy.cost" ) [ set total.energy.cost value ]
            ( breed = anima1s and header = "receiving.history" ) [ set receiving.history value ]
            ( breed = anima1s and header = "carried.history" ) [ set carried.history value ]
            ( breed = anima1s and header = "aid.history" ) [ set aid.history value ]
            ( breed = anima1s and header = "harm.history" ) [ set harm.history value ]
            ( breed = anima1s and header = "copulations.history" ) [ set copulations.history value ]
            ( breed = anima1s and header = "conceptions.history" ) [ set conceptions.history value ]
            ( breed = anima1s and header = "group.transfers.history" ) [ set group.transfers.history value ]
            ( breed = anima1s and header = "infanticide.history" ) [ set infanticide.history value ]
            
            [ ]) 
          
          set j j + 1 ] 
        set i i + 1 ] ]
    
    ; create new meta.ids for everyone
    let table-of-ids table:make
    ask anima1s [
      
      ifelse ( table:has-key? table-of-ids meta.id ) 
      [ let new-id random 9999999
        table:put table-of-ids meta.id new-id
        set meta.id new-id ]
      
      [ table:put table-of-ids meta.id meta.id ]]
    
    ; update carried items list
    ask anima1s [
      if ( is-string? carried.items and length carried.items > 0 ) [ set carried.items run-result carried.items ]
      if ( not is-list? carried.items ) [ set carried.items [] ]
      foreach carried.items [ itm -> set carried.items remove itm ( lput one-of anima1s with [ meta.id  = ( table:get table-of-ids itm ) ] carried.items ) ] ]
    
    ; update mother identity
    ask anima1s [
      if ( my.mother = 0 or my.mother = "nobody" ) [ set my.mother nobody ]
      if ( member? my.mother table:keys table-of-ids ) [ 
        set my.mother one-of anima1s with [ table:get table-of-ids [my.mother] of myself = meta.id  ] ]]
    
    ; general initialization of variables
    ask anima1s [
      
      ; initialize lists
      set receiving.history []
      set carried.history []
      set aid.history []
      set harm.history []
      set group.transfers.history []
      set copulations.history []
      set conceptions.history []
      set cells.occupied []
      set infanticide.history []
      set decision.vectors []
      set my.environment []
      set actions.completed []
      set label-color white
      
      ; compatibility with previous versions
      if ( yellow.signal = 0 ) [ set yellow.signal false ]
      if ( red.signal = 0 ) [ set red.signal false ]
      if ( blue.signal = 0 ) [ set blue.signal false ]
      if ( visual.angle = 0 ) [ set visual.angle 0.5 ]
      if ( visual.range = 0 ) [ set visual.range 0.9 ]
      if ( day.perception = 0 ) [ set day.perception 0.9 ]
      if ( night.perception = 0 ) [ set night.perception 0.25 ]
      if ( bite.capacity = 0 ) [ set bite.capacity 0.2 ]
      if ( is.alive = 0 ) [ set is.alive true ]
      if ( is.resting = 0 ) [ set is.resting false ]
      if ( fully.decayed = 0 ) [ set fully.decayed false ]
      if ( hidden.chance = 0 ) [ set hidden.chance 0 ]
      
      set shape get-shape ; since this is automatically generated each timestep, it does not matter what is in csv file, more compatible this way
      update-appearance ; One the agent is updated with its attributes, update its appearance to match
    ]
    
    update-metafile "population" population (word "POPULATION " population " IMPORTED")
    output-print " Population import successful."
    
  ][ set population "" ] ; If the population file cannot be found, set the population textbox to blank
  
end

;--------------------------------------------------------------------------------------------------------------------
;
; STORE COMPLETE INFORMATION ABOUT AN AGENT POPULATION INTO A FILE
;
; This is a turtle-only function that allows it to record any VARIABLES-TO-RECORD (state-variables and other information 
; it has access to) on external file FILENAME. FILENAME contains rows representing eacn turtle and columns representing 
; the variables associated with those turtles.
;
; CALLER: observer
; FILNAME: includes the full directory path to appropriate CSV file (if one does not exist, it will be created here).
; VARIABLES-TO-RECORD: is a list of string names that the caller-turtle has access to, including global variables, 
; function outputs, and its own state variables.
;
; ENTRY
;
; EXIT
;
; THINGS TO KEEP IN MIND:
;  - You should save ids rather than direct turtle references and fix with code after because who cannot be modified.
;  - You CAN save multiple different turtles breeds to the same file
;  - can handle booleans, numbers, strings, and lists of turtles, numbers, strings, or booleans, and csv-formatted list
;
;--------------------------------------------------------------------------------------------------------------------

to save-population
  output-header (word " SAVE POPULATION : " population )
  
  let filename (word path-to-experiment population ".csv")
  
  ifelse ( file-exists? filename )
  [ 
    ; popup window options if population file already exists
    let answer user-yes-or-no? 
    (word "The population \"" population "\" already exists! " 
      "Click YES overwrite the existing file with the current population, "
      "NO to save the current population to a different randomly generated file name, "
      "or HALT to forget the whole darn thing." )
    ifelse ( answer ) 
    [ file-delete filename save-population ]                       ; YES
    [ reset-population-button save-population ]                    ; NO
    
  ][
    
    let body []
    
    ; list of turtle state variables to save
    let header (list 
      "breed" 
      "meta.id" 
      "age"
      "color" 
      "heading" 
      "xcor" 
      "ycor" 
      "label" 
      "label-color"
      "shape" 
      "hidden?" 
      "size" 
      "pen-size" 
      "pen-mode"
      "biological.sex" 
      "life.history" 
      "female.fertility" 
      "group.identity"    
      "is.alive" 
      "is.resting"
      "yellow.signal" 
      "red.signal" 
      "blue.signal"
      "survival.chance" 
      "body.size" 
      "body.shade" 
      "energy.supply" 
      "identity.I" 
      "identity.II"
      "carried.items"
      "bite.capacity" 
      "mutation.chance" 
      "sex.ratio" 
      "litter.size" 
      "conception.chance"
      "visual.angle"
      "visual.range"
      "day.perception"
      "night.perception"
      "yellow.chance" 
      "red.chance" 
      "blue.chance"
      "birthing.chance" 
      "weaning.chance"
      "infancy.chance"
      "juvenility.chance" 
      "adulthood.chance"
      "x.magnitude"
      "y.magnitude"
      "chromosome.I" 
      "chromosome.II" 
      "my.mother" )
    
    ask turtles [ 
      if ( is-anima1? self ) [ set my.mother ifelse-value ( my.mother != nobody ) [ [meta.id] of my.mother ] [ nobody ] ]
      
      let data-list []
      
      foreach header [ text ->

        let value (ifelse-value 
          ( text = "breed" ) [ breed ]
          ( text = "meta.id" ) [ meta.id ]
          ( text = "age" ) [ age.in.ticks ]
          ( text = "color" ) [ color ]
          ( text = "heading" ) [ heading ]
          ( text = "xcor" ) [ xcor ]
          ( text = "ycor" ) [ ycor ]
          ( text = "label" ) [ label ]
          ( text = "label-color" ) [ label-color ]
          ( text = "shape" ) [ shape ]
          ( text = "hidden?" ) [ hidden? ]
          ( text = "size" ) [ size ]
          ( text = "pen-size" ) [ pen-size ]
          ( text = "pen-mode" ) [ pen-mode ]
          ( text = "biological.sex" ) [ biological.sex ]
          ( text = "life.history" ) [ life.history ]
          ( text = "female.fertility" ) [ female.fertility ]
          ( text = "group.identity" ) [ group.identity ]
          ( text = "is.alive" ) [ is.alive ]
          ( text = "is.resting" ) [ is.resting ]
          ( text = "yellow.signal" ) [ yellow.signal ]
          ( text = "red.signal" ) [ red.signal ]
          ( text = "blue.signal" ) [ blue.signal ]
          ( text = "survival.chance" ) [ survival.chance ]
          ( text = "body.size" ) [ body.size ]
          ( text = "body.shade" ) [ body.shade ]
          ( text = "energy.supply" ) [ energy.supply ]
          ( text = "identity.I" ) [ identity.I ]
          ( text = "identity.II" ) [ identity.II ]
          ( text = "carried.items" ) [ map [ i -> ifelse-value ( is-anima1? i ) [ [meta.id] of i ] [ nobody ] ] carried.items ] 
          ( text = "bite.capacity" ) [ bite.capacity ]
          ( text = "mutation.chance" ) [ mutation.chance ]
          ( text = "sex.ratio" ) [ sex.ratio ]
          ( text = "litter.size" ) [ litter.size ]
          ( text = "conception.chance" ) [ conception.chance ]
          ( text = "visual.angle" ) [ visual.angle ]
          ( text = "visual.range" ) [ visual.range ]
          ( text = "day.perception" ) [ day.perception ]
          ( text = "night.perception" ) [ night.perception ]
          ( text = "yellow.chance" ) [ yellow.chance ]
          ( text = "red.chance" ) [ red.chance ]
          ( text = "blue.chance" ) [ blue.chance ]
          ( text = "birthing.chance" ) [ birthing.chance ]
          ( text = "weaning.chance" ) [ weaning.chance ]
          ( text = "infancy.chance" ) [ infancy.chance ]
          ( text = "juvenility.chance" ) [ juvenility.chance ]
          ( text = "adulthood.chance" ) [ adulthood.chance ]
          ( text = "x.magnitude" ) [ x.magnitude ]
          ( text = "y.magnitude" ) [ y.magnitude ]
          ( text = "chromosome.I" ) [ csv:to-string chromosome.I ]
          ( text = "chromosome.II" ) [ csv:to-string chromosome.II ]
          ( text = "my.mother" ) [ my.mother ])
        
        set data-list lput value data-list ]
      
      set body lput data-list body
      
      if ( is-anima1? self ) [ set my.mother ifelse-value ( my.mother != nobody ) [ one-of anima1s with [ meta.id  = [my.mother] of myself ]] [ nobody ] ]
    ]
    
    if ( file-exists? filename )
    [ 
      file-open filename
      csv:to-file filename ( sentence (list header ) body )
      file-close
      update-metafile "population" population (word "POPULATION " population " SAVED")
      output-print " Population successfully saved."
    ]
    
  ]
end

;----------------------------------------------------------------------------------------------
;
; IMPORT INFORMATION FROM GENOTYPE FILE AND REPLACE AGENT GENOTYPES WITH INFORMATION
; 
; This subroutine reads genotype information from an extrnal file and makes copies of that information
; to store in the chromosomes of all agents in the population.
;
; ENTRY
;
; EXIT
;
;----------------------------------------------------------------------------------------------

to import-genotype
  output-header (word " IMPORT GENOTYPE : " genotype )
  
  let first-codon-list [ "[0]" "[1]" "[2]" "[3]" "[4]" "[5]" ]
  
  let file-to-open ( word path-to-experiment genotype ".txt" ) ; first try accessing file in designated file path
  if not file-exists? file-to-open [ set file-to-open ( word "../data/" genotype ".txt" ) ] ; then try the data folder
  
  ifelse file-exists? file-to-open [  ; check in both places
    
    ask anima1s [
      
      set chromosome.I []
      set chromosome.II []
      
      file-open file-to-open
      let first-chromosome? true 
      while [ not file-at-end? ] [
        let row (csv:from-row file-read-line " ")
        
        ifelse ( row = [""] ) 
        [ set row false ]         ; If row is "empty" converted to format for next line
        [
 
          let contains-a-codon? false                                      ; Initially, the current allele is not known to contain a legitimate codon ( based on current genotype reader )
          let filtered-allele []                                           ; Make a new allele that is empty
          
          foreach row [ itm ->                                          ; For each codon in the allele...
            
            if ( subject = self ) [ print itm ]
            
            let codon-exists ( ifelse-value                                ; ...Check if the codon exists in the current genotype reader lexicon
              ( genotype-reader = "sta2us" ) [ sta2us-codon-exists itm ]   ; - sta2us genotype reader check
              ( genotype-reader = "gat3s" ) [ gat3s-codon-exists itm ]     ; - gat3s genotype reader check
              [ sta2us-codon-exists itm ])                                 ; - or sta2us by default
            
            if codon-exists [                                              ; If the current codon IS in the current genotype reader lexicon
              set contains-a-codon? true ]                                 ; Acknowledge that the current allele contains a legitimate codon
            
            if codon-exists or is-number? itm or is-boolean? itm or member? itm first-codon-list [         ; If current codon IS part of lexicon, OR it is either a number or boolean
              set filtered-allele lput itm filtered-allele ]               ; Add the current codon to the new allele
          ]
          
          set row ifelse-value ( contains-a-codon? )                        ; If current allele contains a legitimate codon
          [ filtered-allele ]                                              ; report the new allele 
          [ false ]                                                        ; Report FALSE to communicate that this allele should not be imported to population

        ]
        
        (ifelse 
          ( row = false                            ; If the row from the genotype file contains nothing
            and length chromosome.I > 0 )          ; And the first chromosome contains at least one allele
          [ set first-chromosome? false ]          ; Switch to filling in the second chromosome with alleles
          
          ( first-chromosome? )                    ; If currently filling in first chromosome
          [ if ( row != false ) 
            [ set chromosome.I lput row chromosome.I ]]
          [ if ( row != false ) 
            [ set chromosome.II lput row chromosome.II ]])
        
      ]
      file-close
    ]
    
    update-metafile "genotype" genotype (word "GENOTYPE " genotype " IMPORTED")
    output-print " Genotype import successful."
    
  ] [ set genotype "" ]
  
end

;----------------------------------------------------------------------------------------------
;
; SAVE GENOTYPE OF SELECTED INDIVIDUAL AND STORE IN EXTERNAL TXT FILE
;
; This subroutine creates an external file with complete information from a single agent. This
; information can then be used to later import this information into a new simulation.
;
; ENTRY
;
; EXIT
;
;----------------------------------------------------------------------------------------------

to save-genotype
  output-header (word " SAVE GENOTYPE : organism " meta.id  )
  if ( genotype = "" ) [ if ( subject != nobody ) [ set genotype (word [meta.id] of subject ) ]]
  ( csv:to-file ( word path-to-experiment genotype ".txt" ) (sentence chromosome.I [[]] chromosome.II ) " " )
  update-metafile "genotype" genotype (word "GENOTYPE " genotype " SAVED")
  output-print " Genotype successfully saved."
end


; ========================================================================================================= ;  
;
;
;  dP 888888ba  d888888P  88888888b  888888ba   88888888b  .d888888   a88888b.  88888888b 
;  88 88    `8b    88     88         88    `8b  88        d8'    88  d8'   `88  88        
;  88 88     88    88    a88aaaa    a88aaaa8P' a88aaaa    88aaaaa88a 88        a88aaaa    
;  88 88     88    88     88         88   `8b.  88        88     88  88         88        
;  88 88     88    88     88         88     88  88        88     88  Y8.   .88  88        
;  dP dP     dP    dP     88888888P  dP     dP  dP        88     88   Y88888P'  88888888P 
;  
; This extension handles operations that relate to user interactions with the interface, including
; parameter settings, commands, and button clicks. 
;
; © 2021 K N Crouse   
;
; ========================================================================================================= ;

; --------------------------------------------------------------------------------------------------------- ;                                                                                         
;                                                                                        
;  dP                  dP     dP                              
;  88                  88     88                              
;  88d888b. dP    dP d8888P d8888P .d8888b. 88d888b. .d8888b. 
;  88'  `88 88    88   88     88   88'  `88 88'  `88 Y8ooooo. 
;  88.  .88 88.  .88   88     88   88.  .88 88    88       88 
;  88Y8888' `88888P'   dP     dP   `88888P' dP    dP `88888P' 
;                                                             
; --------------------------------------------------------------------------------------------------------- ;  

; --------------------------------------------------------------------------------------------------------- ;
;
; PATH BUTTON HANDLER
;
; ENTRY: User has clicked the "path" button.
;
; EXIT: The path subroutine is enacted.
;
; --------------------------------------------------------------------------------------------------------- ;

to path-button
  
  let path user-directory
  let current-position position model-name path
  
  ifelse ( current-position = false ) [
    
    user-message (word "Please choose from within the " model-name " folder.")
    
  ][
    
    while [ is-number? current-position ] [
      
      set path substring path ( current-position + length model-name ) (length path)
      set current-position position model-name path
    ]
    
    set path-to-experiment (word ".." path )
    
  ]
  
end

; --------------------------------------------------------------------------------------------------------- ;
;
; SETUP BUTTON HANDLER [CL]
;
; ENTRY: User has clicked the "setup" button.
;
; EXIT: The setup subroutine is enacted.
;
; --------------------------------------------------------------------------------------------------------- ;

to setup-button  
  if ( simulation-id != 0 and ticks > 100000 )    ; If there is a current simulation that has already been
  [ record-world ]                                ; running for a while then first record the simulation world
  setup                                              
end

; --------------------------------------------------------------------------------------------------------- ;
;
; GO BUTTON HANDLER
;
; ENTRY: User has clicked the "go" button.
;
; EXIT: The go subroutine is enacted.
;
; --------------------------------------------------------------------------------------------------------- ;

to go-button
  ifelse ( simulation-id != 0 )
  [ go ]
  [ let user-setup-response false
    set user-setup-response user-yes-or-no? "Would you like to start a new simulation?"
    ifelse ( user-setup-response ) [ setup ] [ stop ] ]
end


; --------------------------------------------------------------------------------------------------------- ;
;
; RESET POPULATION BUTTON HANDLER
;
; ENTRY: User has clicked the population "⟳" button.
;
; EXIT: The setup subroutine is enacted.
;
; --------------------------------------------------------------------------------------------------------- ;

to reset-population-button
  set population generate-population-id
end

; --------------------------------------------------------------------------------------------------------- ;
;
; EXPORT POPULATION BUTTON HANDLER
;
; ENTRY: User has clicked the "setup" button.
;
; EXIT: The setup subroutine is enacted.
;
; --------------------------------------------------------------------------------------------------------- ;

to export-population-button
  if ( any? anima1s ) [ save-population ]
end

; --------------------------------------------------------------------------------------------------------- ;
;
; IMPORT POPULATION BUTTON HANDLER
;
; ENTRY: User has clicked the "setup" button.
;
; EXIT: The setup subroutine is enacted.
;
; --------------------------------------------------------------------------------------------------------- ;

to import-population-button
  import-population
end

; --------------------------------------------------------------------------------------------------------- ;
;
; RESET GENOTYPE BUTTON HANDLER
;
; ENTRY: User has clicked the genotype "⟳" button.
;
; EXIT: The setup subroutine is enacted.
;
; --------------------------------------------------------------------------------------------------------- ;

to reset-genotype-button
  set genotype generate-genotype-id
end

; --------------------------------------------------------------------------------------------------------- ;
;
; EXPORT GENOTYPE BUTTON HANDLER
;
; ENTRY: User has clicked the "setup" button.
;
; EXIT: The setup subroutine is enacted.
;
; --------------------------------------------------------------------------------------------------------- ;

to export-genotype-button
  if ( subject != nobody ) [ ask one-of anima1s with [ subject = self ] [ save-genotype ]]
end

; --------------------------------------------------------------------------------------------------------- ;
;
; IMPORT GENOTYPE BUTTON HANDLER
;
; ENTRY: User has clicked the "setup" button.
;
; EXIT: The setup subroutine is enacted.
;
; --------------------------------------------------------------------------------------------------------- ;

to import-genotype-button
  import-genotype
end

; --------------------------------------------------------------------------------------------------------- ;  
;
;                                                                  dP          
;                                                                  88          
;  .d8888b. .d8888b. 88d8b.d8b. 88d8b.d8b. .d8888b. 88d888b. .d888b88 .d8888b. 
;  88'  `"" 88'  `88 88'`88'`88 88'`88'`88 88'  `88 88'  `88 88'  `88 Y8ooooo. 
;  88.  ... 88.  .88 88  88  88 88  88  88 88.  .88 88    88 88.  .88       88 
;  `88888P' `88888P' dP  dP  dP dP  dP  dP `88888P8 dP    dP `88888P8 `88888P' 
;                                                                              
; --------------------------------------------------------------------------------------------------------- ;

; --------------------------------------------------------------------------------------------------------- ;
;
; TRIGGER OPERATION BASED ON USEFUL-COMMANDS SETTING [CL]
;
; ENTRY: User has clicked the "▷" button.
;
;        Useful-commands contains a value.
;
; EXIT: The operation selected by useful-commands is enacted.
;
; --------------------------------------------------------------------------------------------------------- ;

to command
  
  ( ifelse 
    
    ( useful-commands = "help-me" ) [ help-me ]
    ( useful-commands = "meta-report" ) [ meta-report ]
    
    ( useful-commands = "parameter-settings" ) [ parameter-report ]
    ( useful-commands = "default-settings" ) [ default-settings ]
    ( useful-commands = "model-structure" ) [ set-model-structure ]
    ( useful-commands = "-- aspatial" ) [ set-model-structure ]
    ( useful-commands = "-- free-lunch" ) [ set-model-structure ]
    ( useful-commands = "-- ideal-form" ) [ set-model-structure ]
    ( useful-commands = "-- no-evolution" ) [ set-model-structure ]
    ( useful-commands = "-- no-plants" ) [ set-model-structure  ]
    ( useful-commands = "-- reaper" ) [ set-model-structure ]
    ( useful-commands = "-- stork" ) [ set-model-structure ]
    ( useful-commands = "-- uninvadable" ) [ set-model-structure ]
    ( useful-commands = "clear-population" ) [ clear-population ]
    ( useful-commands = "reset-plants" ) [ reset-plants ]
    ( useful-commands = "save-notes" ) [ update-metafile "simulation" simulation-id "NOTES SAVED" ]
    ( useful-commands = "save-world" ) [ record-world-command ]
    ( useful-commands = "import-world" ) [ import-world-command ]
    ( useful-commands = "output-results" ) [ output-results-command ]
    ( useful-commands = "dynamic-check" ) [ dynamic-verification ]
    ( useful-commands = "-- true" ) [ dynamic-verification ]
    ( useful-commands = "-- false" ) [ dynamic-verification ]
    ( useful-commands = "runtime-check" ) [ runtime-verification ]
    ( useful-commands = "visual-check" ) [ visual-verification ]
    ( useful-commands = "-- attack-pattern" ) [ visual-verification ]
    ( useful-commands = "-- dine-and-dash" ) [ visual-verification ]
    ( useful-commands = "-- life-history-channel" ) [ visual-verification ]
    ( useful-commands = "-- musical-pairs" ) [ visual-verification ]
    ( useful-commands = "-- night-and-day" ) [ visual-verification ]
    ( useful-commands = "-- popularity-context" ) [ visual-verification ]
    ( useful-commands = "-- speed-mating" ) [ visual-verification ]
    ( useful-commands = "-- square-dance" ) [ visual-verification ]
    ( useful-commands = "-- supply-and-demand" ) [ visual-verification ]
    ( useful-commands = "genotype" ) [ display-results output-genotype  ]
    ( useful-commands = "-- environment" ) [ display-results environment-check ]
    ( useful-commands = "-- decisions" ) [ display-results output-decisions ] 
    ( useful-commands = "-- actions" ) [ display-results output-actions ] 
    ( useful-commands = "show-territories" ) [ output-territories  ]
    
    [ display-results  ]) 

end

; --------------------------------------------------------------------------------------------------------- ;
;
; 
;
; ENTRY: 
;
; EXIT: 
;
; --------------------------------------------------------------------------------------------------------- ;

to output-header [ header-title ]
  if ( behaviorspace-run-number = 0 ) [  ; If a BehaviorSpace run is not occurring
      clear-output                       ; Clear current text in output window, and print header with HEADER-TITLE
      output-print " ---------------------------------------------------------------------------"
      output-print ( word " " header-title )
      output-print " ---------------------------------------------------------------------------"
  ]
end

; --------------------------------------------------------------------------------------------------------- ;
;
; DISPLAY ALL USEFUL-COMMANDS AND THEIR FUNCTIONS [CL]
; 
; This subroutine serves as a directory to display all useful-commands and a brief description of 
; what operation is performed.
;
; ENTRY: User has triggered the help-me command.
;
; EXIT: The help-me subroutine is enacted.
;
; --------------------------------------------------------------------------------------------------------- ;

to help-me
  
  output-header " HELP ME: a user guide for commands"
  
  output-print " Select a command option from the useful-commands dropdown menu and"
  output-print " click ▷ to activate the command. A description of each command is listed "
  output-print " below. "
  output-print ""
  output-print "  help-me : displays this directory"
  output-print "  meta-report : displays a summary of recent user activities"
  output-print "" 
  output-print "  > OPERATIONS"
  output-print ""
  output-print "  parameter-settings : displays the current parameter settings"
  output-print "  default-settings : resets all parameters to default settings"
  output-print "  model-structure : displays the current model-structure settings"
  output-print "  -- aspatial : allows interactions among non-local individuals"
  output-print "  -- free-lunch : allows individuals to act even if they are depleted of energy "
  output-print "  -- ideal-form : newly conceived individuals acquire traits representing the population average"
  output-print "  -- no-evolution : the evolutionary mechanisms are disabled"
  output-print "  -- no-plants : plant growth is inhibited"
  output-print "  -- reaper : individuals are randomly selected to die"
  output-print "  -- stork : individuals are randomly selected to reproduce"
  output-print "  -- uninvadable : evolution occurs with recombination but without mutation"
  output-print "  clear-population : removes all individuals from the current simulation"
  output-print "  reset-plants : replenishes the world with plants"
  output-print "  save-world : saves a NetLogo “World” file"
  output-print "  import-world : opens a previously saved NetLogo “World” file"
  output-print "  results-settings : enables user to update results settings"
  output-print ""
  output-print "  > VERIFICATION "
  output-print ""
  output-print "  dynamic-check : checks that simulation is performing within expected bounds"
  output-print "  -- true : only displays checks that return true"
  output-print "  -- false : only displays checks that return false"
  output-print "  runtime-check : checks the current runtime performance of the simulation"
  output-print "  visual-check : lists available test populations"
  output-print "  -- attack-pattern : tests the moving and attacking actions."
  output-print "  -- dine-and-dash : tests the moving, turning, and eating actions"
  output-print "  -- life-history-channel : tests the development actions"
  output-print "  -- musical-pairs : tests the complex moving actions"
  output-print "  -- night-and-day : tests the basic actions for increasing and decreasing attributes"
  output-print "  -- popularity-context : tests the actions for joining and leaving groups"
  output-print "  -- speed-mating : tests the actions for mating."
  output-print "  -- square-dance : tests the actions for picking up and putting down objects"
  output-print "  -- supply-and-demand : tests the supply and demand actions"
  output-print ""
  output-print "  > DISPLAY RESULTS   "
  output-print ""
  output-print "  age"
  output-print "  generations"
  output-print "  genotype : "
  output-print "  phenotype"
  output-print "  -- survival-chance"
  output-print "  -- body-size"
  output-print "  -- body-shade"
  output-print "  -- fertility-status"
  output-print "  -- hidden-chance"
  output-print "  -- bite-capacity"
  output-print "  -- mutation-chance"
  output-print "  -- sex-ratio"
  output-print "  -- litter-size"
  output-print "  -- conception-chance"
  output-print "  -- visual-angle"
  output-print "  -- visual-range"
  output-print "  -- day-perception"
  output-print "  -- night-perception"
  output-print "  carried-items"
  output-print "  energy-supply"
  output-print "  behaviors"
  output-print "  -- environment : "
  output-print "  -- decisions : "
  output-print "  -- actions : "
  output-print "  -- matings"
  output-print "  -- mating-partners"
  output-print "  -- conceptions"
  output-print "  -- infanticide"
  output-print "  -- group-transfers"
  output-print "  -- travel-distance"
  output-print "  -- foraging-gains"
  output-print "  -- total-energy-gains"
  output-print "  -- total-energy-cost"
  output-print "  show-territories : "
  
end

; --------------------------------------------------------------------------------------------------------- ;
;
; DISPLAY
;  ; Fix cutting off letters at beginning
;
; ENTRY: User has triggered the command.
;
; EXIT: Display is updated
;
; --------------------------------------------------------------------------------------------------------- ;

to meta-report
  output-header ( word "META REPORT " )
  
  ifelse ( file-exists? "../data/metafile.csv" ) [
    
    let metafile but-first csv:from-file "../data/metafile.csv"
    let how-many-rows length metafile
    let up-to-40-rows ifelse-value ( how-many-rows > 40 ) 
    [ sublist metafile ( how-many-rows - 40 ) ( how-many-rows ) ] [ metafile ]
    
    foreach up-to-40-rows [ x -> 
      let data-string item 0 x
      let sim-id item 5 x
      let notes item 9 x 
      let how-many-chars length notes
      let up-to-35-chars ifelse-value ( how-many-chars > 35 ) 
      [ substring notes ( how-many-chars - 35 ) ( how-many-chars ) ] [ notes ]
      output-print (word " " data-string "  " sim-id "  " up-to-35-chars ) ]
    
  ][ output-print " Metafile is currently empty." ]
  
end

; --------------------------------------------------------------------------------------------------------- ;
;
; DISPLAY THE CURRENT PARAMETER SETTINGS OF THE SIMULATION
; 
;
; ENTRY: User has triggered the parameter-settings command.
;
; EXIT: Display is updated
;
; --------------------------------------------------------------------------------------------------------- ;

to parameter-report
  output-header ( word " SIMULATION REPORT : " )
  
  output-print ( word "  simulation-id:  " simulation-id )
  output-print ( word "  model-version:  " model-version )
  output-print ( word "  model-structure:  " model-structure )
  output-print ( word "  genotype-reader:  " genotype-reader )
  output-print ( word "  deterioration-rate:  " deterioration-rate )
  output-print ( word "  maximum-visual-range:  " maximum-visual-range )
  output-print ( word "  base-litter-size:  " base-litter-size )
end

; --------------------------------------------------------------------------------------------------------- ;
;  
; DEFAULT SETTINGS
; 
;
; ENTRY: User has triggered the parameter-settings command.
;
; EXIT: Display is updated
;
; --------------------------------------------------------------------------------------------------------- ;

to default-settings
  
  set path-to-experiment "../results/"
  set output-results? false
  set selection-on? false
  set simulation-notes ""
  set plant-annual-cycle 1000
  set plant-daily-cycle 10
  set plant-seasonality 0.5
  set plant-quality 5.0
  set plant-minimum-neighbors 0
  set plant-maximum-neighbors 8
  set population "population"
  set genotype "genotype"
  clear-plot
  clear-output

  parameter-report
  
end

; --------------------------------------------------------------------------------------------------------- ;
;  
; MODEL STRUCTURE
; 
;
; ENTRY: User has triggered the parameter-settings command.
;
; EXIT: Display is updated
;
; --------------------------------------------------------------------------------------------------------- ;

to set-model-structure
  output-header ( word " MODEL STRUCTURE " )
  let structure-list [ "aspatial" "free-lunch" "ideal-form" "no-evolution" "no-plants" "reaper" "stork" "uninvadable" ]
  let structure-choice substring useful-commands 3 length useful-commands
  
  if ( member? structure-choice structure-list ) [
    ifelse ( not member? structure-choice model-structure )
    [ set model-structure lput structure-choice model-structure ]
    [ set model-structure remove structure-choice model-structure ]
  ]
  
  output-print " "
  output-print "  Current rules:"
  output-print " "
  foreach model-structure [ s -> output-print (word "  " s ) ]
  output-print " "
  output-print "  Unused rules:"
  output-print " "
  foreach structure-list [ l -> if ( not member? l model-structure ) [ output-print (word "  " l )]]
  
end

; --------------------------------------------------------------------------------------------------------- ;
;  
; CLEAR POPULATION
; 
;
; ENTRY: User has triggered the parameter-settings command.
;
; EXIT: Display is updated
;
; --------------------------------------------------------------------------------------------------------- ;

to clear-population
  output-header "CLEAR POPULATION "
  ask turtles [ die ]
  ask patches [ set pgroup.identity 0 ]
  ask patches [ set pgroups.here [] ]
  output-print " All organisms have been virtually incinerated and no longer exist."
end

; --------------------------------------------------------------------------------------------------------- ;
;  
; RESET PLANTS
; 
;
; ENTRY: User has triggered the parameter-settings command.
;
; EXIT: Display is updated
;
; --------------------------------------------------------------------------------------------------------- ;

to reset-plants
  output-header " RESET PLANTS :   "
  setup-patches
  output-print " Plants reset."
end

; --------------------------------------------------------------------------------------------------------- ;
;  
; RESET PLANTS
; 
;
; ENTRY: User has triggered the parameter-settings command.
;
; EXIT: Display is updated
;
; --------------------------------------------------------------------------------------------------------- ;

to record-world-command
  record-world
end

; --------------------------------------------------------------------------------------------------------- ;
;  
; RESET PLANTS
; 
;
; ENTRY: User has triggered the parameter-settings command.
;
; EXIT: Display is updated
;
; --------------------------------------------------------------------------------------------------------- ;

to import-world-command
  ;set-current-directory path-to-experiment  - only uncomment if you have figured out how to get back to original directory at the end of this subroutine
  let file-name user-file
  if ( is-string? file-name and file-exists? file-name ) [ 
    print file-name
    import-world file-name 
    let file-short-name substring file-name 
    ( ( position but-first but-first path-to-experiment file-name ) + 
      ( length but-first but-first path-to-experiment ) ) ( length file-name )
    update-metafile "world" file-name (word "WORLD " file-short-name " IMPORTED" )
  ] 
end

; --------------------------------------------------------------------------------------------------------- ;
;  
; OUTPUT RESULTS
; 
;
; ENTRY: User has triggered the parameter-settings command.
;
; EXIT: Display is updated
;
; --------------------------------------------------------------------------------------------------------- ;

to output-results-command
  output-header " OUTPUT RESULTS :   " 
end

; --------------------------------------------------------------------------------------------------------- ;
;  
; OUTPUT RESULTS
; 
;
; ENTRY: User has triggered the parameter-settings command.
;
; EXIT: Display is updated
;
; --------------------------------------------------------------------------------------------------------- ;   

to dynamic-verification
  let user-choice substring useful-commands 5 length useful-commands
  
  profiler:start
  profiler:reset

  
  go
  
  ( ifelse
    
    ( user-choice = "true" ) [
      output-header " CODE VERIFICATION : TRUE ONLY  "
      output-true-verification ]
    
    ( user-choice = "false" ) [
      output-header " CODE VERIFICATION : FALSE ONLY   "
      output-false-verification ]
    
    [ output-header " CODE VERIFICATION :  ALL  "
      output-all-verification ])
  
  ;profiler:stop
  
end

; --------------------------------------------------------------------------------------------------------- ;
;  
; OUTPUT RESULTS
; 
;
; ENTRY: User has triggered the parameter-settings command.
;
; EXIT: Display is updated
;
; --------------------------------------------------------------------------------------------------------- ;  


to output-all-verification
  clear-output
  let new-tape generate-verification-tape
  let length-of-tape length first new-tape
  let i 0
  
  while [ i < length-of-tape ]
  [
    (ifelse 
      ( i < 4 ) [output-print (word " "  item i item 0 new-tape " " item i item 3 new-tape ) if ( i = 3 ) [ output-print ( "     " ) ] ]
      [ output-print (word " " (i - 3) ". " item i item 3 new-tape "  " item i item 2 new-tape "  " item i item 1 new-tape "  :  " item i item 0 new-tape )])
    set i i + 1
  ]  
end

to output-true-verification
  clear-output
  let new-tape generate-verification-tape
  let length-of-tape length first new-tape
  let i 0
  let j 0
  while [ i < length-of-tape ]
  [
    (ifelse 
      ( i < 4 ) [output-print (word " "  item i item 0 new-tape " " item i item 3 new-tape ) if ( i = 3 ) [ output-print ( "     " ) ] ]
      [ if (item i item 3 new-tape = true ) [ set j j + 1 output-print (word " " j ". " item i item 3 new-tape " " item i item 2 new-tape " " item i item 1 new-tape " : " item i item 0 new-tape ) ]])
    set i i + 1
  ]
end

to output-false-verification
  clear-output
  let new-tape generate-verification-tape
  let length-of-tape length first new-tape
  let i 0
  let j 0
  while [ i < length-of-tape ]
  [
    (ifelse 
      ( i < 4 ) [output-print (word " " item i item 0 new-tape " " item i item 3 new-tape ) if ( i = 3 ) [ output-print ( "     " ) ] ]
      [ if (item i item 3 new-tape = false) [ set j j + 1 output-print (word " " j ". " item i item 3 new-tape " " item i item 2 new-tape " " item i item 1 new-tape " : " item i item 0 new-tape ) ]])
    set i i + 1
  ]
end

to output-verification [ input ]
  clear-output
  let new-tape generate-verification-tape
  let length-of-tape length first new-tape
  let i 0
  
  while [ i < length-of-tape ]
  [
    (ifelse 
      ( i < 4 ) [output-print (word " "  item i item 0 new-tape " " item i item 3 new-tape ) if ( i = 3 ) [ output-print ( "     " ) ] ]
      [ output-print (word " " (i - 3) ". " item i item 3 new-tape "  " item i item 2 new-tape "  " item i item 1 new-tape "  :  " item i item 0 new-tape )])
    set i i + 1
  ]  
end

; --------------------------------------------------------------------------------------------------------- ;
;  
; OUTPUT RESULTS
; 
;
; ENTRY: User has triggered the parameter-settings command.
;
; EXIT: Display is updated
;
; --------------------------------------------------------------------------------------------------------- ;  

to runtime-verification
    output-header (word "CHECK RUNTIME : 1 timesteps")
    profiler:reset
    profiler:start
    repeat 1 [ go ]
    output-print profiler:report 
    profiler:stop
end

; --------------------------------------------------------------------------------------------------------- ;
;  
; OUTPUT RESULTS
; 
;
; ENTRY: User has triggered the parameter-settings command.
;
; EXIT: Display is updated
;
; --------------------------------------------------------------------------------------------------------- ;   

to visual-verification
  let user-choice substring useful-commands 3 length useful-commands
  let visual-list [ "dine-and-dash" "life-history-channel" "musical-pairs" "night-and-day" "popularity-context" "speed-mating" "square-dance" "supply-and-demand" "attack-pattern" ]
  
  if ( member? user-choice visual-list ) [
    
    let visual-verification-file ( word "../data/visual-verification/" user-choice ".csv" )
    
    ifelse ( file-exists? visual-verification-file )
    
    [ set output-results? false
      set selection-on? false
      clear-turtles
      set path-to-experiment "../data/visual-verification/"
      set population user-choice 
      set genotype user-choice 
      import-population 
      import-genotype
    ]
    
    [ user-message "File not found." ]
    
  ]
end

; --------------------------------------------------------------------------------------------------------- ;
;
; SUBROUTINE
; 
; THis subroutine...
;
; ENTRY: 
;
; EXIT: The operation is enacted.
;
; --------------------------------------------------------------------------------------------------------- ;

to output-genotype
  let anima1-to-inspect one-of anima1s with [ self = subject ]
  output-header (word " GENOTYPE : " ifelse-value ( anima1-to-inspect = nobody ) [ "" ] [ (word "organism " [my.identity ] of anima1-to-inspect ) ] )
  ifelse ( anima1-to-inspect = nobody ) [
    ;set simulation-notes (word "Organism " read-from-string command-input " not found.")
    ;output-print (word " Organism " read-from-string command-input " not found.")
  ][
    foreach [chromosome.I] of anima1-to-inspect [ a ->
      output-print (word " "reduce [ [itm nxt] -> (word itm " " nxt ) ] a ) ]
    output-print ""
    foreach [chromosome.II] of anima1-to-inspect [ a ->
      output-print (word " "reduce [ [itm nxt] -> (word itm " " nxt ) ] a ) ]
    ;set simulation-notes (word "View genotype of organism " command-input ". " simulation-notes )
  ]
end

; --------------------------------------------------------------------------------------------------------- ;
;
; SUBROUTINE
; 
; THis subroutine...
;
; ENTRY: 
;
; EXIT: The operation is enacted.
;
; --------------------------------------------------------------------------------------------------------- ;

to environment-check
  let anima1-to-inspect one-of anima1s with [ self = subject ]
  output-header ( word " ENVIRONMENT : " ifelse-value ( anima1-to-inspect = nobody ) [ "all individuals" ] [ (word "individual " [my.identity ] of anima1-to-inspect ) ] )
  ifelse ( subject != nobody ) [
    output-print ( word "  NetLogo ID    B3GET ID    status     " )
    output-print " ------------------------------------"
    ask subject [
      foreach my.environment [ envir -> 
        let indiv-name but-first but-last (word envir )
        let their-id ifelse-value ( is-patch? envir ) [ pmy.identity ] [ my.identity ]
        output-print ( word "  " indiv-name "    " their-id "    " status-of envir )
    ]]
    
  ][
    
    
    
    
  ]
end

; --------------------------------------------------------------------------------------------------------- ;
;
; SUBROUTINE
; 
; THis subroutine...
;
; ENTRY: 
;
; EXIT: The operation is enacted.
;
; --------------------------------------------------------------------------------------------------------- ;

to output-decisions
  let anima1-to-inspect one-of anima1s with [ self = subject ]
  output-header (word " DECISIONS : " ifelse-value ( anima1-to-inspect = nobody ) [ "all individuals" ] [ (word "individual " [my.identity ] of anima1-to-inspect ) ] )
  output-print ( word "  caller      target      action       cost     " )
  output-print " ------------------------------------------"
  
  ifelse ( anima1-to-inspect != nobody ) [ 
  
    ask anima1-to-inspect [
      foreach decision.vectors [ decision ->
        let caller-name but-first but-last (word item 0 decision )
        let target-name but-first but-last (word item 1 decision )
        let action-name item 2 decision
        let cost-name precision item 3 decision 10
        output-print ( word " " caller-name "   " target-name "   " action-name "   " cost-name  )]]
    
    
  ][ 
    foreach decisions-made-this-timestep [ decision -> 
        let caller-name but-first but-last (word item 0 decision )
        let target-name but-first but-last (word item 1 decision )
        let action-name item 2 decision
        let cost-name precision item 3 decision 10
        output-print ( word " " caller-name "   " target-name "   " action-name "   " cost-name  )]]
end


; --------------------------------------------------------------------------------------------------------- ;
;
; SUBROUTINE
; 
; THis subroutine...
;
; ENTRY: 
;
; EXIT: The operation is enacted.
;
; --------------------------------------------------------------------------------------------------------- ; 

to output-actions
  let anima1-to-inspect one-of anima1s with [ self = subject ]
  output-header (word " ACTIONS : " ifelse-value ( anima1-to-inspect = nobody ) [ "all individuals" ] [ (word "individual " [my.identity ] of anima1-to-inspect ) ] )
  output-print ( word "  caller      action      target       cost     " )
  output-print " ------------------------------------------"
  
  ifelse ( anima1-to-inspect != nobody ) [ 
    
    ask anima1-to-inspect [
      foreach actions.completed [ action -> 
        let caller-name but-first but-last (word item 0 action )
        let target-name but-first but-last (word item 1 action )
        let action-name item 2 action
        let cost-name precision item 3 action 10
        output-print ( word " " caller-name "   " target-name "   " action-name "   " cost-name  )]]
    
  ][ 
    foreach actions-completed-this-timestep [ action -> 
      let caller-name but-first but-last (word item 0 action )
      let target-name but-first but-last (word item 1 action )
      let action-name item 2 action
      let cost-name precision item 3 action 10
      output-print ( word " " caller-name "   " action-name "   " target-name "   " cost-name  )]
    ;output-print get-spaced-words ( list caller-name action-name target-name cost-name ) 20 ]
  ]
  
end

; --------------------------------------------------------------------------------------------------------- ;
;
; SUBROUTINE
; 
; THis subroutine...
;
; ENTRY: 
;
; EXIT: The operation is enacted.
;
; --------------------------------------------------------------------------------------------------------- ;

to output-print-action [ action ]
  output-print ( word " At " item 0 action " timesteps " item 1 action " performed " item 3 action " on " item 2 action " for " item 4 action " energy." )
end

; --------------------------------------------------------------------------------------------------------- ;
;
; SUBROUTINE
; 
; THis subroutine...
;
; ENTRY: 
;
; EXIT: The operation is enacted.
;
; --------------------------------------------------------------------------------------------------------- ;

to output-territories
  ask patches [ if ( pgroup.identity != 0 ) [ set pcolor pgroup.identity + 3 ]]
  
  foreach remove-duplicates [ group.identity ] of anima1s [ grp ->
    print ( word grp " " count patches with [ pgroup.identity = grp ] ) 
    
  ]
end

; --------------------------------------------------------------------------------------------------------- ;  
;
;           dP            dP            
;           88            88            
;  88d888b. 88 .d8888b. d8888P .d8888b. 
;  88'  `88 88 88'  `88   88   Y8ooooo. 
;  88.  .88 88 88.  .88   88         88 
;  88Y888P' dP `88888P'   dP   `88888P' 
;  88                                   
;  dP                                  
;
; --------------------------------------------------------------------------------------------------------- ;  

; --------------------------------------------------------------------------------------------------------- ;
;
; DISPLAY PLOT FROM USER SETTINGS
; 
; THis subroutine...
;
; ENTRY:  User 
;
; EXIT: The operation is enacted.
;
; --------------------------------------------------------------------------------------------------------- ;
 
to display-results 
  
  if ( simulation-id != 0 ) [ ; commands only work when a simulation is active
    
    (ifelse 
      ( plot-type = "individuals" ) [ plot-individuals-columns ]
      ( plot-type = "groups" )      [ plot-groups-columns ]
      ( plot-type = "generations" ) [ plot-evolution-generations ]
     
      [])] 
end

; --------------------------------------------------------------------------------------------------------- ;     
;
; PLOT INDIVIDUALS ACCORDING TO THE SPECIFIED SETTINGS
;
; ENTRY
;
; EXIT     get-sorted-individuals
;
;          plot-colored-histogram
;
;          life-history-color-list
;
;          get-column-list
;
; --------------------------------------------------------------------------------------------------------- ;

to plot-individuals-columns
  let individual-list get-sorted-individuals                        ; Get sorted list of living agents
  let plot-list []                                                  ; Initialize list of values to be plotted
  let row-list []
  foreach individual-list [ i ->
    set row-list lput [my.identity] of i row-list
    set plot-list lput ( 
      [ get-column-list ] of i ) 
    plot-list ]
  plot-colored-histogram 1 plot-list life-history-color-list 1      ; Update plot based on plot list
 
  output-window plot-type "" (list "column" "my.identity" plot-type ) row-list plot-list 0 0 0
end

; --------------------------------------------------------------------------------------------------------- ;
;
; GET LIST OF FILTERED AND SORTED INDIVIDUALS
;
; This subroutine is used to obtain a sorted and filtered list of agents, sorted by the button settings  
; located above the plot in the interface. If one button is selected, the collection only contains individuals
; of the selected type. For example, turning on the "females" which results in only female information 
; displayed in the plot. If multiple buttons of the same type are selected, the collection is sorted by those
; attributes.
; 
; ENTRY: The switches for 'gestatees,' 'infants,' 'juveniles,' 'adults,' 'females,' 'males' may be selected.
;
; EXIT: Returns a list of agents, sorted and filtered by parameter specifications.
;
; --------------------------------------------------------------------------------------------------------- ;

to-report get-sorted-individuals 
  let sorted-filtered-list sort-on [ age.in.ticks ] anima1s with [ is.alive ]

  set sorted-filtered-list filter [ i -> ( gestatees and infants and juveniles and adults ) or
    ( not gestatees and not infants and not juveniles and not adults ) or
    ( adults and [life.history] of i = "adult" ) or 
    ( juveniles and [life.history] of i = "juvenile" ) or 
    ( infants and [life.history] of i = "infant" ) or 
    ( gestatees and [life.history] of i = "gestatee" ) ] sorted-filtered-list
  set sorted-filtered-list filter [ i -> ( males and females ) or
    ( not males and not females ) or
    ( females and [biological.sex] of i = "female" ) or 
    ( males and [biological.sex] of i = "male" ) ] sorted-filtered-list
  report sorted-filtered-list
end

; --------------------------------------------------------------------------------------------------------- ;     
;
; COLUMN LIST
;
; This subroutine is called by the anima1s class. It creates a list of zeros and a single non-zero number.
; The placement of the non-zero number with respect to the other zeros signifies the kind of anima1 by
; sex, life history stage and fertility status. For example, if this subroutine returned [ 0 0 0 0 1 0 0 0 0 0 ] 
; then the individual is a juvenile female. The non-zero value is determined by user settings and handled by 
; the 'get-data-from-user-selection' subroutine.
;
; ENTRY: 
;
; EXIT:  The 'get-data-from-user-selection' reports a number based on user input.
;
; --------------------------------------------------------------------------------------------------------- ;

to-report get-column-list
  let report-list []
  set report-list lput (ifelse-value ( life.history = "gestatee" and biological.sex = "female" ) [ get-data-from-user-selection ] [ 0 ]) report-list 
  set report-list lput (ifelse-value ( life.history = "gestatee" and biological.sex = "male" ) [ get-data-from-user-selection ] [ 0 ]) report-list
  set report-list lput (ifelse-value ( life.history = "infant" and biological.sex = "female" ) [ get-data-from-user-selection ] [ 0 ]) report-list
  set report-list lput (ifelse-value ( life.history = "infant" and biological.sex = "male" ) [ get-data-from-user-selection ] [ 0 ]) report-list
  set report-list lput (ifelse-value ( life.history = "juvenile" and biological.sex = "female" ) [ get-data-from-user-selection ] [ 0 ]) report-list
  set report-list lput (ifelse-value ( life.history = "juvenile" and biological.sex = "male" ) [ get-data-from-user-selection ] [ 0 ]) report-list
  set report-list lput (ifelse-value ( fertility.status = "cycling" and biological.sex = "female" ) [ get-data-from-user-selection ] [ 0 ]) report-list
  set report-list lput (ifelse-value ( fertility.status = "pregnant" and biological.sex = "female" ) [ get-data-from-user-selection ] [ 0 ]) report-list
  set report-list lput (ifelse-value ( fertility.status = "lactating" and biological.sex = "female" ) [ get-data-from-user-selection ] [ 0 ]) report-list
  set report-list lput (ifelse-value ( life.history = "adult" and biological.sex = "male" ) [ get-data-from-user-selection ] [ 0 ]) report-list
  report report-list
end

; --------------------------------------------------------------------------------------------------------- ;     
;
; PLOT INDIVIDUALS ACCORDING TO THE SPECIFIED SETTINGS
;
; The order is: female gestatee, male gestatee, female infant, male infant, female juvenile, male juvenile, 
; cycling female, pregnant female, lactating female, adult male.
;
; ENTRY
;
; EXIT
;
; --------------------------------------------------------------------------------------------------------- ;

to-report life-history-color-list 
  report [ 25 15 45 35 65 55 135 125 115 95 ]
end

; --------------------------------------------------------------------------------------------------------- ;
;
; HELPER FUNCTION THAT RETURNS INFORMATION
;
; ENTRY: The useful-commands menu has a selection.
;
; EXIT
;
; --------------------------------------------------------------------------------------------------------- ;

to-report get-data-from-user-selection
  report (ifelse-value
    ( useful-commands = "age" ) [ age.in.ticks ]
    ( useful-commands = "generations" ) [ generation.number ]
    ( useful-commands = "genotype" ) [ length ( sentence chromosome.I chromosome.II ) ]
    ( useful-commands = "-- survival-chance" ) [ survival.chance ]
    ( useful-commands = "-- body-size" ) [ body.size ]
    ( useful-commands = "-- body-shade" ) [ body.shade ]
    ( useful-commands = "-- fertility-status" ) [ 
      (ifelse-value (fertility.status = "lactating") [ 3 ] 
      ( fertility.status = "pregnant" ) [ 2 ] 
        ( fertility.status = "cycling" ) [ 1 ] [ 0 ]) ]
    ( useful-commands = "-- hidden-chance" ) [ hidden.chance ]
    ( useful-commands = "-- bite-capacity" ) [ bite.capacity ]    
    ( useful-commands = "-- mutation-chance" ) [ mutation.chance ]
    ( useful-commands = "-- sex-ratio" ) [ sex.ratio ]
    ( useful-commands = "-- litter-size" ) [ litter.size ]
    ( useful-commands = "-- conception-chance" ) [ conception.chance ]
    ( useful-commands = "-- visual-angle" ) [ visual.angle ]
    ( useful-commands = "-- visual-range" ) [ visual.range ]
    ( useful-commands = "-- day-perception" ) [ day.perception ]
    ( useful-commands = "-- night-perception" ) [ night.perception ]
    ( useful-commands = "-- yellow-chance" ) [ yellow.chance ]
    ( useful-commands = "-- red-chance" ) [ red.chance ]
    ( useful-commands = "-- blue-chance" ) [ blue.chance ]
    ( useful-commands = "-- birthing-chance" ) [ birthing.chance ]
    ( useful-commands = "-- weaning-chance" ) [ weaning.chance ]
    ( useful-commands = "-- infancy-chance" ) [ infancy.chance ]
    ( useful-commands = "-- juvenility-chance" ) [ juvenility.chance ]
    ( useful-commands = "-- adulthood-chance" ) [ adulthood.chance ]
    ( useful-commands = "carried-items" ) [ length carried.items ]
    ( useful-commands = "energy-supply" ) [ energy.supply ]
    ( useful-commands = "-- environment" ) [ length my.environment ]
    ( useful-commands = "-- decisions" ) [ length decision.vectors ]
    ( useful-commands = "-- actions" ) [ length actions.completed ]    
    ( useful-commands = "-- birthing" ) [ ifelse-value ( mother.initiated.birth = true ) [ 1 ] [ 0 ] ]
    ( useful-commands = "-- weaning" ) [ ifelse-value ( mother.initiated.weaning = true ) [ 1 ] [ 0 ] ]
    ( useful-commands = "-- matings" ) [ length copulations.history ]
    ( useful-commands = "-- mating-partners" ) [ length remove-duplicates copulations.history ]
    ( useful-commands = "-- conceptions" ) [ length conceptions.history ]
    ( useful-commands = "-- infanticide" ) [ length infanticide.history ]
    ( useful-commands = "-- group-transfers" ) [ length group.transfers.history ]
    ( useful-commands = "-- travel-distance" ) [ distance.traveled ]
    ( useful-commands = "-- foraging-gains" ) [ foraging.gains ]
    ( useful-commands = "-- total-energy-gains" ) [ total.energy.gains ]
    ( useful-commands = "-- total-energy-cost" ) [ total.energy.cost ]
    ( useful-commands = "-- help-history" ) [ length help.from.history ]
    ( useful-commands = "-- attack-history" ) [ length attack.from.history ]
    
    [ 0 ])
end

; --------------------------------------------------------------------------------------------------------- ;
;
; PRINT SPECIFIED AGENT INFORMATION TO OUTPUT WINDOW
;
; This subroutine...
;
; ENTRY
;
; EXIT
;
; --------------------------------------------------------------------------------------------------------- ;

to output-window [ input blurb column-list row-list plot-list key-code bar-code print-code ]

  output-header ( word "PLOT: " input " of " get-life-history-filter get-sex-filter plot-type )
  output-print (word " x: " plot-type )
  output-print (word " y: " input )
  output-print ""
  let column-header-string " "
  foreach column-list [ c -> set column-header-string ( word column-header-string  c "   ") ]
  output-print column-header-string
  let index 0
  foreach row-list [ r ->
    output-print (word "   [" (index + 1) "]     " ( item index row-list ) "     " ( max item index plot-list  ))      
    set index index + 1
  ]
  
end

; --------------------------------------------------------------------------------------------------------- ;
;
; PRINT SPECIFIED AGENT INFORMATION TO OUTPUT WINDOW
;
; This subroutine...
;
; ENTRY
;
; EXIT
;
; --------------------------------------------------------------------------------------------------------- ;

to-report get-life-history-filter
  report (ifelse-value
    ( gestatees )[ "gestatee " ]
    ( infants )[ "infant " ]
    ( juveniles )[ "juvenile " ]
    ( adults )[ "adult " ]
    [ "" ])    
end

; --------------------------------------------------------------------------------------------------------- ;
;
; PRINT SPECIFIED AGENT INFORMATION TO OUTPUT WINDOW
;
; This subroutine...
;
; ENTRY
;
; EXIT
;
; --------------------------------------------------------------------------------------------------------- ;

to-report get-sex-filter
  report (ifelse-value
    ( females )[ "female " ]
    ( males )[ "male " ]
    [ "" ]) 
end

; --------------------------------------------------------------------------------------------------------- ;     
;     
; GROUPS
;
; ENTRY
;
; EXIT
;
; --------------------------------------------------------------------------------------------------------- ;

to plot-groups-columns
  let sorted-groups get-sorted-groups
  let group-list [] 
  let color-list []
  let row-list []
  let selected-individuals get-sorted-individuals
  foreach sorted-groups [ g ->
    set row-list lput g row-list
    let list-for-calculating-median [ get-data-from-user-selection ] of anima1z with [ group.identity = g and member? self selected-individuals]
    set group-list lput ( ifelse-value ( length list-for-calculating-median > 0 ) [ median list-for-calculating-median ] [ 0 ] ) group-list
    set color-list lput ( wrap-color g ) color-list ]
  
  let plot-list []
  let i 0
  let j 0
  foreach group-list [ itm ->
    let row-list-2 []
    foreach group-list [
      set row-list-2 lput ifelse-value ( i = j ) [ itm ][ 0 ] row-list-2
      set j j + 1
    ]
    set plot-list lput row-list-2 plot-list
    set i i + 1
    set j 0
  ]
  ; print plot-list
  plot-colored-histogram 1 plot-list color-list 1
  
  ;output-window plot-type "" (list "column" "my.identity" plot-type ) row-list plot-list 0 0 0
end

to-report get-sorted-groups
  report sort remove-duplicates [group.identity] of anima1s with [ is.alive and not solitary? ]
end

; --------------------------------------------------------------------------------------------------------- ;     
; 
; EVOLUTION
;
; ENTRY
;
; EXIT
;
; --------------------------------------------------------------------------------------------------------- ;

to plot-evolution-generations
  let selected-individuals get-sorted-individuals
  let max-generation max [generation.number] of anima1s with [member? self selected-individuals ]
  let plot-list []
  let generation 0
  repeat ( max-generation + 1 ) [
    let evol-list [ get-data-from-user-selection ] of anima1s with [ generation.number = generation and member? self selected-individuals ]
    let agent-count ifelse-value ( length evol-list > 0 ) [ mean evol-list ] [ 0 ]
    set plot-list lput ( list agent-count ) plot-list
    set generation generation + 1
  ]
  plot-colored-histogram 1 plot-list [ black ] 1
end

; --------------------------------------------------------------------------------------------------------- ;     
;   
; HELPER HISTOGRAM PLOTTING
;
; ENTRY
;
; EXIT
;
; --------------------------------------------------------------------------------------------------------- ; 

to plot-colored-histogram [ column-interval plot-list color-list plot-type-1 ]
  clear-all-plots
  set-current-plot "plot"
  set-plot-pen-interval 0.01
  set-plot-pen-mode 1
  
  let index 0
  foreach plot-list [ column ->
    let y-so-far 0
    let column-index 0
    foreach column [ c ->
      set y-so-far c
      let index-2 0
      repeat ( 70 * column-interval ) [
        set-plot-pen-color item column-index color-list
        plot-pen-down
        plotxy ( index + 0.1 + index-2 ) y-so-far
        set index-2 index-2 + 0.01
        plot-pen-up ]
      set column-index column-index + 1
    ]
    set index index + column-interval ]  
  
  set-plot-pen-color pink ; reset "cycling female" label back to pink
end


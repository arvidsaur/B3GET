
;--------------------------------------------------------------------------------------------------------------------
;
;   oo            dP                     .8888b
;                 88                     88   "
;   dP 88d888b. d8888P .d8888b. 88d888b. 88aaa  .d8888b. .d8888b. .d8888b.
;   88 88'  `88   88   88ooood8 88'  `88 88     88'  `88 88'  `"" 88ooood8
;   88 88    88   88   88.  ... 88       88     88.  .88 88.  ... 88.  ...
;   dP dP    dP   dP   `88888P' dP       dP     `88888P8 `88888P' `88888P'
;
; © 2021 K N Crouse   
;--------------------------------------------------------------------------------------------------------------------

to setup-button  
  if ( simulation-id != 0 and ticks > 100000 )       ; If there is a current simulation that has already been running for a while
  [ record-world ]                                   ; Record the simulation world
  setup                                              
end

to go-button
  ifelse ( simulation-id != 0 )
  [ go ]
  [ let user-setup-response false
    set user-setup-response user-yes-or-no? "Would you like to start a new simulation?"
    ifelse ( user-setup-response ) [ setup ] [ stop ] ]
end

to save-button
  if ( simulation-id = 0 ) [ set simulation-id generate-simulation-id ]
  update-metafile "simulation" simulation-id "SIMULATION SAVED."
end

to reset-population-button
  set population generate-population-id
end

to export-population-button
  if ( any? anima1s ) [ save-population ]
end

to import-population-button
  import-population
end

to reset-genotype-button
  set genotype generate-genotype-id
end

to export-genotype-button
  if ( subject != nobody ) [ ask one-of anima1s with [ subject = self ] [ save-genotype ]]
end

to import-genotype-button
  import-genotype
end

;-----------------------------------------------------------------------------
;                                                                dP          
;                                                                88          
; .d8888b. .d8888b. 88d8b.d8b. 88d8b.d8b. .d8888b. 88d888b. .d888b88 .d8888b. 
; 88'  `"" 88'  `88 88'`88'`88 88'`88'`88 88'  `88 88'  `88 88'  `88 Y8ooooo. 
; 88.  ... 88.  .88 88  88  88 88  88  88 88.  .88 88    88 88.  .88       88 
; `88888P' `88888P' dP  dP  dP dP  dP  dP `88888P8 dP    dP `88888P8 `88888P' 
;                                                                            
;-----------------------------------------------------------------------------                                                                          

to command
  
  ( ifelse 
    
    ( useful-commands = "help-me" ) [ help-me ]
    ( useful-commands = "meta-report" ) [ meta-report ]
    
    ( useful-commands = "parameter-settings" ) [ parameter-report ]
    ( useful-commands = "default-settings" ) [ default-settings ]
    ( useful-commands = "model-structure" ) [ set-model-structure ]
    ( useful-commands = "-- aspatial" ) [ set-model-structure ]
    ( useful-commands = "-- free-lunch" ) [ set-model-structure ]
    ( useful-commands = "-- ideal-form" ) [ set-model-structure ]
    ( useful-commands = "-- no-evolution" ) [ set-model-structure ]
    ( useful-commands = "-- no-plants" ) [ set-model-structure  ]
    ( useful-commands = "-- reaper" ) [ set-model-structure ]
    ( useful-commands = "-- signal-fertility" ) [ set-model-structure ]
    ( useful-commands = "-- stork" ) [ set-model-structure ]
    ( useful-commands = "-- uninvadable" ) [ set-model-structure ]
    ( useful-commands = "clear-population" ) [ clear-population ]
    ( useful-commands = "new-population" ) [ ]      
    ( useful-commands = "reset-plants" ) [ output-reset-plants ]
    ( useful-commands = "save-world" ) [ record-world ]
    ( useful-commands = "import-world" ) [ import-world-command ]
    ( useful-commands = "save-simulation" ) [  ]
    
    ( useful-commands = "dynamic-check" ) [ dynamic-verification ]
    ( useful-commands = "-- true" ) [ dynamic-verification ]
    ( useful-commands = "-- false" ) [ dynamic-verification ]
    ( useful-commands = "runtime-check" ) [ runtime-verification ]
    ( useful-commands = "visual-check" ) [ visual-verification ]
    ( useful-commands = "-- attack-pattern" ) [ visual-verification ]
    ( useful-commands = "-- dine-and-dash" ) [ visual-verification ]
    ( useful-commands = "-- life-history-channel" ) [ visual-verification ]
    ( useful-commands = "-- musical-pairs" ) [ visual-verification ]
    ( useful-commands = "-- night-and-day" ) [ visual-verification ]
    ( useful-commands = "-- popularity-context" ) [ visual-verification ]
    ( useful-commands = "-- speed-mating" ) [ visual-verification ]
    ( useful-commands = "-- supply-and-demand" ) [ visual-verification ]
    ( useful-commands = "-- square-dance" ) [ visual-verification ]
    
    ( useful-commands = "-- decisions" ) [ display-results ] ;output-decisions
    ( useful-commands = "-- actions" ) [ display-results ] ; output-actions 
    ( useful-commands = "genotype" ) [ output-genotype  ]
    
    [ display-results ])
  
  

  ;"age"
  ;"generations"
  ;"life-history"
  ;"genotype"
  ;"phenotype"
  ;"-- survival-chance"
  ;"-- body-size"
  ;"-- body-shade"
  ;"-- female-fertility" ;; new
  ;"-- hidden-chance"
  ;"-- bite-capacity"
  ;"-- mutation-chance"
  ;"-- sex-ratio"
  ;"-- litter-size"
  ;"-- conception-chance"
  ;"-- visual-angle"
  ;"-- visual-range"
  ;"-- day-perception"
  ;"-- night-perception"
  ;"-- yellow-chance"
  ;"-- red-chance"
  ;"-- blue-chance"
  ;"-- birthing-chance"
  ;"-- weaning-chance"
  ;"-- infancy-chance"
  ;"-- juvenility-chance"
  ;"-- adulthood-chance"
  ;"carried-items"
  ;"energy-supply"
  ;"behaviors"
  ;-- environment
  ;"-- decisions"
  ;"-- actions"
  ;"-- birthing"
  ;"-- weaning"
  ;"-- matings"
  ;"-- mating-partners"
  ;"-- conceptions"
  ;"-- infanticide"
  ;"-- group-transfers"
  ;"-- travel-distance"
  ;"-- foraging-gains"
  ;"-- total-energy-gains"
  ;"-- total-energy-cost"
  ;"-- receiving-history"
  ;"-- carried-history"
  ;"-- aid-history"
  ;"-- harm-history"



end

to help-me
  
;  output-header " HELP ME: a user guide for commands"
;  output-print " Select a command option from the useful-commands dropdown menu and"
;  output-print " click ▷ to activate the command. A description of each command is listed "
;  output-print " below. "
;  output-print ""
;  output-print " > SIMULATION"
;  output-print ""
;  output-print "  meta-report : prints a summary of user activities"
;  output-print "  dynamic-verify-code : prints a summary of verification code checks"
;  output-print "  visual-verify-code : prints a summary of verification code checks"
;  output-print "  check-runtime : prints a summary of simulation operations"    
;  output-print "  simulation-report : prints a summary of current simulation"
;  ;output-print "  genotype-reader : set the genotype file format of simulation"
;  output-print "  model-structure [ ] : set the model structure for the simulation"
;  output-print ""
;  output-print " > WORLD"
;  output-print ""
;  output-print "  setup-plants : replenishes the world with plants"
;  output-print "  clear-population: removes all organisms from the world"
;  ;output-print "  import-world [ file ] : import world file from experiment folder"
;  output-print ""
;  output-print " > DATA"
;  output-print ""
;  output-print "  view-genotype : prints the genotype of an organism or population"
;  output-print "  view-decisions : shows the decisions of an organism or population"
;  output-print "  view-actions : shows the actions of an organism or population"
;  output-print "  view-history : summarizes history of an organism or population"
;  output-print "  view-status : shows current status of an organism or population"
;  ;output-print "  add-allele [ code ] : add mutation to population"
;  ;output-print "  delete-allele [ code ] : delete allele from everywhere in the population"
;  output-print ""
  
end

to output-header [ header-title ]
  if ( behaviorspace-run-number = 0 ) [  ; If a BehaviorSpace run is not occurring
      clear-output                       ; Clear current text in output window, and print header with HEADER-TITLE
      output-print " ---------------------------------------------------------------------------"
      output-print ( word " " header-title )
      output-print " ---------------------------------------------------------------------------"
  ]
end

;-----------------------------------------------------------------------------       
; META REPORT
;-----------------------------------------------------------------------------       

to meta-report ; Fix cutting off letters at beginning
  output-header ( word "META REPORT " )
  
  let metafile but-first csv:from-file "../results/metafile.csv"
  let how-many-rows length metafile
  let up-to-40-rows ifelse-value ( how-many-rows > 40 ) [ sublist metafile ( how-many-rows - 40 ) ( how-many-rows ) ] [ metafile ]
  
  foreach up-to-40-rows [ x -> 
    let data-string item 0 x
    let sim-id item 5 x
    let notes item 9 x 
    let how-many-chars length notes
    let up-to-35-chars ifelse-value ( how-many-chars > 35 ) [ substring notes ( how-many-chars - 35 ) ( how-many-chars ) ] [ notes ]
    output-print (word " " data-string "  " sim-id "  " up-to-35-chars ) ]
  
end

;-----------------------------------------------------------------------------       
; PARAMETERS
;-----------------------------------------------------------------------------     

to parameter-report
  output-header ( word " SIMULATION REPORT : " )
  output-print ( word "  simulation-id:  " simulation-id )
  output-print ( word "  model-version:  " model-version )
  output-print ( word "  model-structure:  " model-structure )
  output-print ( word "  genotype-reader:  " genotype-reader )
  output-print ( word "  deterioration-rate:  " deterioration-rate )
  output-print ( word "  maximum-visual-range:  " maximum-visual-range )
  output-print ( word "  base-litter-size:  " base-litter-size )
end

;-----------------------------------------------------------------------------       
; DEFAULT SETTINGS
;-----------------------------------------------------------------------------   

to default-settings
  
  set path-to-experiment "../results/"
  set output-results? false
  set selection-on? false
  set observation-notes ""
  set plant-annual-cycle 1000
  set plant-daily-cycle 10
  set plant-seasonality 0.5
  set plant-quality 5.0
  set plant-minimum-neighbors 0
  set plant-maximum-neighbors 8
  set population "Hamadryas"
  set genotype "hamadryas"
  ; plot
  ; output

  parameter-report
  
end


;-----------------------------------------------------------------------------       
; MODEL STRUCTURE
;-----------------------------------------------------------------------------    

to set-model-structure
  output-header ( word " MODEL STRUCTURE " )
  let structure-list [ "aspatial" "free-lunch" "ideal-form" "no-evolution" "no-plants" "reaper" "signal-fertility" "stork" "uninvadable" ]
  let structure-choice substring useful-commands 3 length useful-commands
  
  if ( member? structure-choice structure-list ) [
    ifelse ( not member? structure-choice model-structure )
    [ set model-structure lput structure-choice model-structure ]
    [ set model-structure remove structure-choice model-structure ]
  ]
  
  output-print " "
  output-print "  Current rules:"
  output-print " "
  foreach model-structure [ s -> output-print (word "  " s ) ]
  output-print " "
  output-print "  Unused rules:"
  output-print " "
  foreach structure-list [ l -> if ( not member? l model-structure ) [ output-print (word "  " l )]]
  
end

;-----------------------------------------------------------------------------       
; CLEAR POPULATION
;-----------------------------------------------------------------------------   

to clear-population
  output-header "CLEAR POPULATION "
  ask turtles [ die ]
  output-print " All agents have been virtually incinerated and no longer exist."
end

;-----------------------------------------------------------------------------       
; WORLD
;-----------------------------------------------------------------------------   

;to record-world
;  let file-path ( word path-to-experiment "w" but-first simulation-id "-" ticks ".csv" )
;  export-world file-path
;  update-metafile "world" ( word "w" but-first simulation-id "-" ticks ) ( word "WORLD SAVED" )
;end

to import-world-command
  let file-name user-file
  if ( is-string? file-name and file-exists? file-name ) [ 
    print file-name
    import-world file-name 
    let file-short-name substring file-name ( ( position but-first but-first path-to-experiment file-name ) + ( length but-first but-first path-to-experiment ) ) ( length file-name )
    update-metafile "world" file-name (word "WORLD " file-short-name " IMPORTED" )
  ] 
end

;-----------------------------------------------------------------------------       
; RESET PLANTS
;-----------------------------------------------------------------------------   

to output-reset-plants
  output-header " RESET PLANTS :   "
  setup-patches
  output-print " Plants reset."
end

;-----------------------------------------------------------------------------       
; SEED POPULATION
;-----------------------------------------------------------------------------   

to seed-population
  let population-choice substring useful-commands 3 length useful-commands
  set path-to-experiment "../data/"
  set population population-choice
  set genotype population-choice
  import-population
end

;-----------------------------------------------------------------------------       
; DYNAMIC CHECK
;-----------------------------------------------------------------------------     

to dynamic-verification
  let user-choice substring useful-commands 5 length useful-commands
  
  ( ifelse
    
    ( user-choice = "true" ) [
      output-header " CODE VERIFICATION : TRUE ONLY  "
      output-true-verification ]
    
    ( user-choice = "false" ) [
      output-header " CODE VERIFICATION : FALSE ONLY   "
      output-false-verification ]
    
    [ output-header " CODE VERIFICATION :  ALL  "
      output-all-verification ])
end

;-----------------------------------------------------------------------------       
; RUNTIME CHECK
;-----------------------------------------------------------------------------     

to runtime-verification
    output-header (word "CHECK RUNTIME : " how-many-ticks? " timesteps")
    profiler:reset
    profiler:start
    repeat how-many-ticks? [ go ]
    output-print profiler:report 
    profiler:stop
end

;-----------------------------------------------------------------------------       
; VISUAL CHECK
;-----------------------------------------------------------------------------     

to visual-verification
  let user-choice substring useful-commands 3 length useful-commands
  let visual-list [ "dine-and-dash" "life-history-channel" "musical-pairs" "night-and-day" "popularity-context" "speed-mating" "square-dance" "supply-and-demand" "attack-pattern" ]
  
  if ( member? user-choice visual-list ) [
    
    let visual-verification-file ( word "../data/visual-verification/" user-choice ".csv" )
    
    ifelse ( file-exists? visual-verification-file )
    
    [ set output-results? false
      set selection-on? false
      clear-turtles
      set path-to-experiment "../data/visual-verification/"
      set population user-choice 
      set genotype user-choice 
      import-population 
      import-genotype
    ]
    
    [ user-message "File not found." ]
    
  ]
end

;-----------------------------------------------------------------------------       
; VIEW ACTIONS
;-----------------------------------------------------------------------------   

to output-actions
  let anima1-to-inspect one-of anima1s with [ self = subject ]
  output-header (word " ACTIONS : " ifelse-value ( anima1-to-inspect = nobody ) [ "all individuals" ] [ (word "individual " [meta.id ] of anima1-to-inspect ) ] )
  clear-output
  ifelse ( anima1-to-inspect != nobody ) 
  
  [ ask anima1-to-inspect [
    foreach actions.completed [ action -> output-print action ]]]
  
  [ foreach recent-actions-completed [ action -> output-print-action action ]]
  
end

to output-print-action [ action ]
  output-print ( word " At " item 0 action " timesteps " item 1 action " performed " item 3 action " on " item 2 action " for " item 4 action " energy." )
end

;-----------------------------------------------------------------------------       
; VIEW DECISIONS
;-----------------------------------------------------------------------------   

to output-decisions
  let anima1-to-inspect one-of anima1s with [ self = subject ]
  output-header (word " DECISIONS : " ifelse-value ( anima1-to-inspect = nobody ) [ "all individuals" ] [ (word "individual " [meta.id ] of anima1-to-inspect ) ] )
  clear-output
  ifelse ( anima1-to-inspect != nobody ) 
  
  [ ask anima1-to-inspect [
    foreach decision.vectors [ decision ->
      output-print ( word " " decision )]]]
  
  [ foreach recent-decisions-made [ d -> 
      output-print (word "  " d ) ]]
end

;-----------------------------------------------------------------------------       
; VIEW ENVIRONMENT
;-----------------------------------------------------------------------------  





;-----------------------------------------------------------------------------       
; VIEW GENOTYPE
;-----------------------------------------------------------------------------   

to output-genotype
  let anima1-to-inspect one-of anima1s with [ self = subject ]
  output-header (word " GENOTYPE : " ifelse-value ( anima1-to-inspect = nobody ) [ "" ] [ (word "organism " [meta.id ] of anima1-to-inspect ) ] )
  ifelse ( anima1-to-inspect = nobody ) [
    ;set observation-notes (word "Organism " read-from-string command-input " not found.")
    ;output-print (word " Organism " read-from-string command-input " not found.")
  ][
    foreach [chromosome.I] of anima1-to-inspect [ a ->
      output-print (word " "reduce [ [itm nxt] -> (word itm " " nxt ) ] a ) ]
    output-print ""
    foreach [chromosome.II] of anima1-to-inspect [ a ->
      output-print (word " "reduce [ [itm nxt] -> (word itm " " nxt ) ] a ) ]
    ;set observation-notes (word "View genotype of organism " command-input ". " observation-notes )
  ]
end

;-----------------------------------------------------------------------------   
;
;            dP            dP            
;            88            88            
;   88d888b. 88 .d8888b. d8888P .d8888b. 
;   88'  `88 88 88'  `88   88   Y8ooooo. 
;   88.  .88 88 88.  .88   88         88 
;   88Y888P' dP `88888P'   dP   `88888P' 
;   88                                   
;   dP                                   
;-----------------------------------------------------------------------------   

to display-results 
  
  if ( simulation-id != 0 ) [ ; commands only work when a simulation is active
    
    (ifelse 
      ( plot-type = "individuals" ) [ plot-individuals-columns ]
      ( plot-type = "groups" )      [ plot-groups-columns ]
      ( plot-type = "populations" ) [ plot-population-histogram  ]
      ( plot-type = "generations" ) [ plot-evolution-generations ]
     
      [])] 
end

;-----------------------------------------------------------------------------       
; PLOT INDIVIDUALS ACCORDING TO THE SPECIFIED SETTINGS
;
; ENTRY
;
; EXIT
;-----------------------------------------------------------------------------   

to plot-individuals-columns
  let input selected-display
  let individual-list get-sorted-individuals                        ; get sorted list of living agents
  let plot-list []                                                  ; initialize list of values to be plotted
  let row-list []
  foreach individual-list [ i ->
    set row-list lput [meta.id] of i row-list
    set plot-list lput ( [ get-column-list input ] of i ) plot-list ]
  plot-colored-histogram 1 plot-list life-history-color-list 1                   ; update plot based on plot list
 
  ;output-window input "" (list "column" "meta.id" input ) row-list plot-list 0 0 0
end

to-report get-column-list [ input-string ] ; used if you want to separate by life history and sex colors
  let report-list []
  set report-list lput (ifelse-value ( life.history = "gestatee" and biological.sex = "female" ) [ get-result-from-selected-display ] [ 0 ]) report-list 
  set report-list lput (ifelse-value ( life.history = "gestatee" and biological.sex = "male" ) [ get-result-from-selected-display ] [ 0 ]) report-list
  set report-list lput (ifelse-value ( life.history = "infant" and biological.sex = "female" ) [ get-result-from-selected-display ] [ 0 ]) report-list
  set report-list lput (ifelse-value ( life.history = "infant" and biological.sex = "male" ) [ get-result-from-selected-display ] [ 0 ]) report-list
  set report-list lput (ifelse-value ( life.history = "juvenile" and biological.sex = "female" ) [ get-result-from-selected-display ] [ 0 ]) report-list
  set report-list lput (ifelse-value ( life.history = "juvenile" and biological.sex = "male" ) [ get-result-from-selected-display ] [ 0 ]) report-list
  set report-list lput (ifelse-value ( female.fertility = "cycling" and biological.sex = "female" ) [ get-result-from-selected-display ] [ 0 ]) report-list
  set report-list lput (ifelse-value ( female.fertility = "pregnant" and biological.sex = "female" ) [ get-result-from-selected-display ] [ 0 ]) report-list
  set report-list lput (ifelse-value ( female.fertility = "lactating" and biological.sex = "female" ) [ get-result-from-selected-display ] [ 0 ]) report-list
  set report-list lput (ifelse-value ( life.history = "adult" and biological.sex = "male" ) [ get-result-from-selected-display ] [ 0 ]) report-list
  report report-list
end

to-report life-history-color-list ; female gestatee, male gestatee, female infant, male infant, female juvenile, male juvenile, cycling female, pregnant female, lactating female, adult male
  report [ 65 55 46 43 26 23 135 125 115 95 15 ]
end

;-----------------------------------------------------------------------------       
; GROUPS
;-----------------------------------------------------------------------------   

to plot-groups-columns
  let input selected-display
  let sorted-groups get-sorted-groups
  let group-list [] 
  let color-list []
  let row-list []
  let selected-individuals get-sorted-individuals
  foreach sorted-groups [ g ->
    set row-list lput g row-list
    let list-for-calculating-median [ get-result-from-selected-display ] of anima1z with [ group.identity = g and member? self selected-individuals]
    set group-list lput ( ifelse-value ( length list-for-calculating-median > 0 ) [ median list-for-calculating-median ] [ 0 ] ) group-list
    set color-list lput ( wrap-color g ) color-list ]
  
  let plot-list []
  let i 0
  let j 0
  foreach group-list [ itm ->
    let row-list-2 []
    foreach group-list [
      set row-list-2 lput ifelse-value ( i = j ) [ itm ][ 0 ] row-list-2
      set j j + 1
    ]
    set plot-list lput row-list-2 plot-list
    set i i + 1
    set j 0
  ]
  ; print plot-list
  plot-colored-histogram 1 plot-list color-list 1
  
  ;output-window input "" (list "column" "meta.id" input ) row-list plot-list 0 0 0
end

to-report get-sorted-groups
  report sort remove-duplicates [group.identity] of anima1s with [ is.alive ]
end

;-----------------------------------------------------------------------------       
; POPULATION
;-----------------------------------------------------------------------------   

to plot-population-histogram  ; works! bad runtime
  let max-value max [ get-result-from-selected-display ] of anima1z
  let column-no 10
  let interval precision ( max-value / column-no ) 2
  let plot-list []
  let lower 0
  let upper lower + interval
  let selected-individuals get-sorted-individuals
  let row-list []
  repeat column-no [
   ; print lower
    ;print upper
    set row-list lput (word " " lower " to " upper "") row-list
    let agent-count count anima1z with [ get-result-from-selected-display > lower and get-result-from-selected-display <= upper and member? self selected-individuals]
    ;let subject? any? anima1z with [ subject = self and get-result-from-selected-display > lower and get-result-from-selected-display <= upper and member? self selected-individuals]
    set plot-list lput ( list agent-count ifelse-value ( member? subject selected-individuals ) [ agent-count ][ 0 ] ) plot-list
    set lower lower + interval
    set upper upper + interval ]
  ;print plot-list
  plot-colored-histogram interval plot-list [ black red ] 1
  
  ;output-window input "" (list "column" "interval" "count" ) row-list plot-list 0 0 0
end

;-----------------------------------------------------------------------------       
; EVOLUTION
;-----------------------------------------------------------------------------   

to plot-evolution-generations
  let input selected-display
  let selected-individuals get-sorted-individuals
  let max-generation max [generation.number] of anima1s with [member? self selected-individuals ]
  let plot-list []
  let generation 0
  repeat ( max-generation + 1 ) [
    let evol-list [ get-result-from-selected-display ] of anima1s with [ generation.number = generation and member? self selected-individuals ]
    let agent-count ifelse-value ( length evol-list > 0 ) [ mean evol-list ] [ 0 ]
    set plot-list lput ( list agent-count ) plot-list
    set generation generation + 1
  ]
  plot-colored-histogram 1 plot-list [ black ] 1
end

;-----------------------------------------------------------------------------       
; HELPER FUNCTION THAT RETURNS INFORMATION
;----------------------------------------------------------------------------- 

to-report get-result-from-selected-display
  report (ifelse-value
    ( useful-commands = "age" ) [ age.in.ticks ]
    ( useful-commands = "generations" ) [ generation.number ]
    ( useful-commands = "genotype" ) [ length ( sentence chromosome.I chromosome.II ) ]
    ( useful-commands = "-- survival-chance" ) [ survival.chance ]
    ( useful-commands = "-- body-size" ) [ body.size ]
    ( useful-commands = "-- body-shade" ) [ body.shade ]
    ( useful-commands = "-- female-fertility" ) [ (ifelse-value (female.fertility = "lactating") [ 3 ] ( female.fertility = "pregnant" ) [ 2 ] ( female.fertility = "cycling" ) [ 1 ] [ 0 ]) ]
    ( useful-commands = "-- hidden-chance" ) [ hidden.chance ]
    ( useful-commands = "-- bite-capacity" ) [ bite.capacity ]    
    ( useful-commands = "-- mutation-chance" ) [ mutation.chance ]
    ( useful-commands = "-- sex-ratio" ) [ sex.ratio ]
    ( useful-commands = "-- litter-size" ) [ litter.size ]
    ( useful-commands = "-- conception-chance" ) [ conception.chance ]
    ( useful-commands = "-- visual-angle" ) [ visual.angle ]
    ( useful-commands = "-- visual-range" ) [ visual.range ]
    ( useful-commands = "-- day-perception" ) [ day.perception ]
    ( useful-commands = "-- night-perception" ) [ night.perception ]
    ( useful-commands = "-- yellow-chance" ) [ yellow.chance ]
    ( useful-commands = "-- red-chance" ) [ red.chance ]
    ( useful-commands = "-- blue-chance" ) [ blue.chance ]
    ( useful-commands = "-- birthing-chance" ) [ birthing.chance ]
    ( useful-commands = "-- weaning-chance" ) [ weaning.chance ]
    ( useful-commands = "-- infancy-chance" ) [ infancy.chance ]
    ( useful-commands = "-- juvenility-chance" ) [ juvenility.chance ]
    ( useful-commands = "-- adulthood-chance" ) [ adulthood.chance ]
    ( useful-commands = "carried-items" ) [ length carried.items ]
    ( useful-commands = "energy-supply" ) [ energy.supply ]
    ( useful-commands = "-- environment" ) [ length my.environment ]
    ( useful-commands = "-- decisions" ) [ length decision.vectors ]
    ( useful-commands = "-- actions" ) [ length actions.completed ]    
    ( useful-commands = "-- birthing" ) [ ifelse-value ( mother.initiated.birth = true ) [ 1 ] [ 0 ] ]
    ( useful-commands = "-- weaning" ) [ ifelse-value ( mother.initiated.weaning = true ) [ 1 ] [ 0 ] ]
    ( useful-commands = "-- matings" ) [ length copulations.history ]
    ( useful-commands = "-- mating-partners" ) [ length remove-duplicates copulations.history ]
    ( useful-commands = "-- conceptions" ) [ length conceptions.history ]
    ( useful-commands = "-- infanticide" ) [ length infanticide.history ]
    ( useful-commands = "-- group-transfers" ) [ length group.transfers.history ]
    ( useful-commands = "-- travel-distance" ) [ distance.traveled ]
    ( useful-commands = "-- foraging-gains" ) [ foraging.gains ]
    ( useful-commands = "-- total-energy-gains" ) [ total.energy.gains ]
    ( useful-commands = "-- total-energy-cost" ) [ total.energy.cost ]
    ( useful-commands = "-- receiving-history" ) [ length receiving.history ]
    ( useful-commands = "-- carried-history" ) [ length carried.history ]
    ( useful-commands = "-- aid-history" ) [ length aid.history ]
    ( useful-commands = "-- harm-history" ) [ length harm.history ]
    
    [ 0 ])
end

;-----------------------------------------------------------------------------       
; HELPER HISTOGRAM PLOTTING
;-----------------------------------------------------------------------------   

to plot-colored-histogram [ column-interval plot-list color-list plot-type-1 ]
  clear-all-plots
  set-current-plot "plot"
  set-plot-pen-interval 0.01
  set-plot-pen-mode 1
  
  let index 0
  foreach plot-list [ column ->
    let y-so-far 0
    let column-index 0
    foreach column [ c ->
      set y-so-far c
      let index-2 0
      repeat ( 70 * column-interval ) [
        set-plot-pen-color item column-index color-list
        plot-pen-down
        plotxy ( index + 0.1 + index-2 ) y-so-far
        set index-2 index-2 + 0.01
        plot-pen-up ]
      set column-index column-index + 1
    ]
    set index index + column-interval ]  
end

;-----------------------------------------------------------------------------  
;
; GET LIST OF FILTERED AND SORTED INDIVIDUALS
;
; This subroutine is used to obtain a sorted and filtered list of agents, 
; sorted by the user interface button settings located beneath the plot. 
; If one button selected, the collection only contains agents with the 
; selected attribute. If multiple buttons of the same type are selected, 
; the collection is sorted by those attributes.
; 
; ENTRY: collection of anima1s
;        buttons gestatees, infants, juveniles, adults, females, males
;
; EXIT:  returns list of anima1s sorted by button settings
; 
;----------------------------------------------------------------------------- 

to-report get-sorted-individuals ; returns a list of agents, sorted and filtered by parameter specifications
  let sorted-filtered-list sort-on [ age.in.ticks ] anima1s with [ is.alive ]
  
;  set sorted-filtered-list ifelse-value ( males and females ) [ sort-by [ [i j ] -> [ biological.sex ] of i < [ biological.sex ] of j ] sorted-filtered-list ] [ sorted-filtered-list ]
;  set sorted-filtered-list ifelse-value ( gestatees and infants and juveniles and adults )[ sort-by [ [ i j ] -> [ life-history-number ] of i < [ life-history-number ] of j ] sorted-filtered-list ] [ sorted-filtered-list ]
  set sorted-filtered-list filter [ i -> ( gestatees and infants and juveniles and adults ) or
    ( not gestatees and not infants and not juveniles and not adults ) or
    ( adults and [life.history] of i = "adult" ) or 
    ( juveniles and [life.history] of i = "juvenile" ) or 
    ( infants and [life.history] of i = "infant" ) or 
    ( gestatees and [life.history] of i = "gestatee" ) ] sorted-filtered-list
  set sorted-filtered-list filter [ i -> ( males and females ) or
    ( not males and not females ) or
    ( females and [biological.sex] of i = "female" ) or 
    ( males and [biological.sex] of i = "male" ) ] sorted-filtered-list
  report sorted-filtered-list
end

to-report life-history-number
  report (ifelse-value
    ( life.history = "adult" ) [ 1 ]
    ( life.history = "juvenile" ) [ 2 ]
    ( life.history = "infant" ) [ 3 ]
    ( life.history = "gestatee" ) [ 4 ]
    [ 5 ])
end

;-----------------------------------------------------------------------------  
;
; PRINT SPECIFIED AGENT INFORMATION TO OUTPUT WINDOW
;
; This subroutine...
; 
; ENTRY: 
;
; EXIT:  
; 
;----------------------------------------------------------------------------- 

to output-window [ input blurb column-list row-list plot-list key-code bar-code print-code ]

  output-header ( word "PLOT: " input " of " get-life-history-filter get-sex-filter get-plot-focus-filter )
  output-print (word " x: " get-plot-focus-filter )
  output-print (word " y: " input )
  output-print ""
  print-life-history-key
  output-print ""
  let column-header-string " "
  foreach column-list [ c -> set column-header-string ( word column-header-string  c "   ") ]
  output-print column-header-string
  let index 0
  foreach row-list [ r ->
    output-print (word "   [" (index + 1) "]     " ( item index row-list ) "     " ( max item index plot-list  ))      
    set index index + 1
  ]
  
end

to-report get-life-history-filter
  report (ifelse-value
    ( gestatees )[ "Gestatee " ]
    ( infants )[ "Infant " ]
    ( juveniles )[ "Juvenile " ]
    ( adults )[ "Adult " ]
    [ "" ])    
end

to-report get-sex-filter
  report (ifelse-value
    ( females )[ "Female " ]
    ( males )[ "Male " ]
    [ "" ]) 
end

to-report get-plot-focus-filter
  report (ifelse-value
  ( plot-type = "individuals" )[ "Individuals" ]
  ( plot-type = "groups" )[ "Groups" ]
  ( plot-type = "population" )[ "Population" ]
  ( plot-type = "generations" )[ "Generations" ]
  [ "" ])    
end

to print-life-history-key
  output-print " PLOT KEY :"
  output-print " blue : adult male "
  output-print " pink : cycling female" 
  output-print " magenta : pregnant female"
  output-print " purple : lactating female"
  output-print " brown : juvenile male "
  output-print " orange : juvenile female" 
  output-print " mustard : infant male"
  output-print " sunflower : infant female "
  output-print " forest : gestatee male" 
  output-print " lime : gestatee female"
end



































































;to-report get-column-results [ agent-list stats-list ]
;  
;  let report-list []
;  foreach stats-list [ i ->
;    set report-list (sentence report-list get-stats-results i agent-list )
;  ]
;  report report-list ; concatinated lists of numbers
;end
;
;to-report get-stats-results [ stats-type agent-list ]
;  ; foreach get-value-array, ( for each measurement done)
;  ;    apply stats-type to turn list into number
;  ; therefore end up with one list of numbers, or list of single number 
;  
;  ; return list of numbers
;  let report-list []
;  let values get-value-array agent-list selected-display  
;  
;  foreach values [ v -> 
;    set report-list (ifelse-value
;      ( stats-type = "min" ) [ min v ]
;      ( stats-type = "max" ) [ max v ]
;      ( stats-type = "mean" ) [ mean v ]
;      ( stats-type = "median" ) [ median v ]
;      ( stats-type = "variance" ) [ variance v ]
;      [ count v ])
;  ]
;  report report-list
;  
;;  report (ifelse-value
;;    ( stats-type = "min" ) [ min get-value-array agent-list selected-display ]
;;    [])
;end
;
;to-report get-value-array [ agent-list inputs ] ; returns a list of lists, one list for each measurement done on agent-list
;  let report-list []
;  
;;  foreach inputs [ input ->
;;  
;;  set report-list lput ( ifelse
;;;    ( input = "life-history" ) [ foreach [ "gestation" "lactation" "sexual-maturity" "longevity" ] [ l ->  set report-list lput ( get-value-array agent-list l ) report-list ]]
;;;    ( input = "genotype" )[ get-genotype-measurements agent-list ]
;;;    ( input = "phenotype" )[ get-phenotype-measurements agent-list ] ;
;;;    ( input = "kin-selection" )[ get-kin-sselection-measurements agent-list ] ;
;;;    ( input = "actions" )[ get-action-measurements agent-list ]
;;;    ( input = "decisions" )[ get-decision-measurements agent-list ]
;;    ( input = "age" ) [ set report-list lput [ age.in.ticks ] of agent-list ]
;;    ( input = "generations" ) [ generation.number ]
;;    ( input = "survival-chance" ) [ survival.chance ]
;;    ( input = "body-size" ) [ body.size ]
;;    ( input = "body-shade" ) [ body.shade ]
;;    ( input = "hidden-chance" ) [ hidden.chance ]
;;    ( input = "bite-capacity" ) [ bite.capacity ]    
;;    ( input = "mutation-chance" ) [ mutation.chance ]
;;    ( input = "sex-ratio" ) [ sex.ratio ]
;;    ( input = "litter-size" ) [ litter.size ]
;;    ( input = "conception-chance" ) [ conception.chance ]
;;    ( input = "visual-angle" ) [ visual.angle ]
;;    ( input = "visual-range" ) [ visual.range ]
;;    ( input = "day-perception" ) [ day.perception ]
;;    ( input = "night-perception" ) [ night.perception ]
;;    ( input = "yellow-chance" ) [ yellow.chance ]
;;    ( input = "red-chance" ) [ red.chance ]
;;    ( input = "blue-chance" ) [ blue.chance ]
;;    ( input = "birthing-chance" ) [ birthing.chance ]
;;    ( input = "weaning-chance" ) [ weaning.chance ]
;;    ( input = "infancy-chance" ) [ infancy.chance ]
;;    ( input = "juvenility-chance" ) [ juvenility.chance ]
;;    ( input = "adulthood-chance" ) [ adulthood.chance ]
;;    ( input = "carried-items" ) [ length carried.items ]
;;    ( input = "energy-supply" ) [ energy.supply ]
;;    ( input = "birthing" ) [ ifelse-value ( mother.initiated.birth = true ) [ 2 ] [ 1 ] ]
;;    ( input = "weaning" ) [ ifelse-value ( mother.initiated.weaning = true ) [ 2 ] [ 1 ] ]
;;    ( input = "matings" ) [ length copulations.history ]
;;    ( input = "mating-partners" ) [ length remove-duplicates copulations.history ]
;;    ( input = "conceptions" ) [ length conceptions.history ]
;;    ( input = "infanticide" ) [ length infanticide.history ]
;;    ( input = "group-transfers" ) [ length group.transfers.history ]
;;    ( input = "travel-distance" ) [ distance.traveled ]
;;    ( input = "foraging-gains" ) [ foraging.gains ]
;;    ( input = "total-energy-gains" ) [ total.energy.gains ]
;;    ( input = "total-energy-cost" ) [ total.energy.cost ]
;;    ( input = "receiving.history" ) [ receiving.history ]
;;    ( input = "carried.history" ) [ length carried.history ]
;;    ( input = "aid-history" ) [ length aid.history ]
;;    ( input = "harm-history" ) [ length harm.history ]
;;      
;;    [])
;;  ]
; 
;  report report-list
;end
;
;to-report get-phenotype-measurements
;  
;end
;
;to-report get-genotype-measurements
;  report []
;end
;
;to plot-individuals-decisions 
;  let individual-list get-sorted-individuals                        ; get sorted list of living agents
;  let plot-list []                                                  ; initialize list of values to be plotted
;  
;  let decisions-list [ 
;    "survival-chance" "body-size" "body-shade" 
;    "day-perception" "night-perception" "visual-angle" "visual-range" 
;    "conception-chance" "bite-capacity" "mutation-chance" "sex-ratio" "litter-size" 
;    "turn-right" "turn-left" "go-forward" "set-heading" "set-heading-random" 
;    "hide" "rest" 
;    "yellow-signal" "red-signal" "blue-signal" 
;    "check-infancy" "check-juvenility" "check-adulthood" 
;    "check-birth" "check-weaning" 
;    "move-toward" "move-away-from" "supply-to" "demand-from" "eat"
;    "join" "leave" "recruit" "kick-out"
;    "pick-up" "put-down" "cling-to" "squirm-from"
;    "help" "hurt" "mate-with" ]
;  
;  let color-list [ 
;    3 5 7 
;    12 14 16 18
;    23 25 27 
;    33 37
;    43 45 47 
;    54 56
;    64 67
;    73 75 77
;    82 85 87
;    93 96 
;    103 107 
;    123 125 127
;    132 134 136 138
;    142 144 146 148
;    153 155 157 ]
;  
;  foreach individual-list [ i ->                                    ; loop through each individual
;    
;    foreach decisions-list [ d ->
;      
;      
;    
;;    ifelse ( subject = i )                                          ; check if individual is subject
;;    [ set plot-list lput (list 0 [age.in.ticks] of i ) plot-list ]  ; if yes, then update plot list for red columm
;;    [ set plot-list lput (list [age.in.ticks] of i 0 ) plot-list ]] ; if no, then update plot list for black column
;  ]]
;  ;plot-colored-histogram 1 plot-list color-list                      ; update plot based on plot list
;end
;  
;to plot-groups-groups 
;  let current-groups sort remove-duplicates [group.identity] of anima1s with [ is.alive ]
;  let group-composition-list []
;  
;  foreach current-groups [ group ->
;    let this-group-composition []
;    let y-so-far count anima1s with [ is.alive and group.identity = group ]
;    foreach [ "gestatee" "infant" "juvenile" "adult" ] [ life-stage ->      
;      foreach [ "female" "male" ] [ sex ->
;        set this-group-composition lput y-so-far this-group-composition
;        set y-so-far y-so-far - count anima1s with [ is.alive and group.identity = group and life.history = life-stage and biological.sex = sex ]
;      ]
;    ]
;    set group-composition-list lput this-group-composition group-composition-list
;  ] 
;  ;plot-colored-histogram 1 group-composition-list [ red orange yellow green turquoise sky blue magenta ]
;end
;  
;to plot-lotka-volterra 
;  clear-all-plots
;  set-plot-pen-mode 0
;  set-plot-pen-color green
;  let index 0
;  foreach plant-abundance-record [ p ->
;    plotxy ( 100 * index ) ( ln p )
;    set index index + 1 ]
;  plot-pen-up
;  set index 0
;  set-plot-pen-color brown
;  foreach population-size-record [ s ->
;    plotxy ( 100 * index ) ( ln s )
;    plot-pen-down
;    set index index + 1 ]
;end
;
;
;to reduce-genotype
;  clear-output
;  ;REDUCE DECISIONS TO ONE PER TARGET-ACTION COMBO
;  let reduced-decisions []
;  
;  let input-list ( sentence chromosome.i chromosome.ii )
;  
;  foreach input-list [ original-vector ->
;    let original-ego ifelse-value ( length original-vector > 1 ) [ item 1 original-vector ] [ 0 ]
;    let original-target ifelse-value ( length original-vector > 2 ) [ item 2 original-vector ] [ 0 ]
;    let original-action ifelse-value ( length original-vector > 3 ) [ item 3 original-vector ] [ 0 ]
;    let original-weight ifelse-value ( length original-vector > 4 ) [ item 4 original-vector ] [ 0 ]
;    let vector-doesnt-exist true
;    
;    let index 0
;    foreach reduced-decisions [ reduced-vector ->
;      let reduced-ego ifelse-value ( length reduced-vector > 1 ) [ item 1 reduced-vector ] [ 0 ]
;      let reduced-target ifelse-value ( length reduced-vector > 2 ) [ item 2 reduced-vector ] [ 0 ]
;      let reduced-action ifelse-value ( length reduced-vector > 3 ) [ item 3 reduced-vector ] [ 0 ]
;      let reduced-weight ifelse-value ( length reduced-vector > 4 ) [ item 4 reduced-vector ] [ 0 ]
;      
;      print original-ego
;      print original-target
;      print original-action
;      print original-weight
;      print reduced-ego
;      print reduced-target
;      print reduced-action
;      print reduced-weight
;      
;      if ( reduced-ego = original-ego ) and ( reduced-target = original-target ) and ( reduced-action = original-action ) and is-number? reduced-weight and is-number? original-weight [
;        set vector-doesnt-exist false
;        print "match"
;        let new-vector ( list reduced-ego reduced-target reduced-action ( reduced-weight + original-weight ) )
;        set reduced-decisions remove-item index reduced-decisions
;        set reduced-decisions lput new-vector reduced-decisions ]
;      set index index + 1
;    ]
;    if vector-doesnt-exist [ set reduced-decisions lput ( list original-ego original-target original-action original-weight ) reduced-decisions ]
;    ; print reduced-decisions
;  ]
;  foreach reduced-decisions [ d ->
;    output-print d
;  ]
;end
;
;
;
;
;
;;; detelet?
;
;
;
;
;
;
;
;;-----------------------------------------------------------------------------       
;; AGE HISTOGRAM
;;-----------------------------------------------------------------------------    
;
;;to age-histogram
;;  clear-plot
;;  set-plot-pen-interval 100
;;  set-plot-x-range 0 max [ age.in.ticks ] of anima1s with [ is.alive ]
;;  histogram [ age.in.ticks ] of anima1s with [ is.alive ]
;;end
;
;;;-----------------------------------------------------------------------------       
;;; VIEW HISTORY
;;;-----------------------------------------------------------------------------   
;;
;;to output-history
;;  let anima1-to-inspect one-of anima1s with [ self = subject ]
;;  output-header (word " HISTORY : " ifelse-value ( anima1-to-inspect = nobody ) [ "all individuals" ] [ (word "individual " [meta.id ] of anima1-to-inspect ) ] )
;;  
;;  output-print ( word " Total energy gained: "
;;    ifelse-value ( anima1-to-inspect != nobody ) 
;;    [ [ precision total.energy.gains 2 ] of subject ] 
;;    [ ( word precision ( sum [ total.energy.gains ] of anima1s with [ biological.sex = "female"] ) 2 " (females) " precision ( sum [ total.energy.gains ] of anima1s with [ biological.sex = "male"] ) 2 " (males) " ) ] )
;;  
;;  output-print ( word " Total energy cost: "
;;    ifelse-value ( anima1-to-inspect != nobody ) 
;;    [ [ precision total.energy.cost 2 ] of subject ] 
;;    [ ( word precision ( sum [ total.energy.cost ] of anima1s with [ biological.sex = "female"] ) 2 " (females) " precision ( sum [ total.energy.cost ] of anima1s with [ biological.sex = "male"]) 2 " (males) " ) ] )
;;  
;;  output-print ( word " Total energy gained by foraging: "
;;    ifelse-value ( anima1-to-inspect != nobody ) 
;;    [ [ precision foraging.gains 2 ] of subject ] 
;;    [ ( word precision ( sum [ foraging.gains ] of anima1s with [ biological.sex = "female"] ) 2 " (females) " precision ( sum [ foraging.gains ] of anima1s with [ biological.sex = "male"]) 2 " (males) " ) ] )
;;  
;;  output-print ( word " Number of helpful behaviors: "
;;    ifelse-value ( anima1-to-inspect != nobody ) 
;;    [ [ length aid.history ] of subject ] 
;;    [ ( word sum [ length aid.history ] of anima1s with [ biological.sex = "female"] " (females) " sum [ length aid.history ] of anima1s with [ biological.sex = "male"] " (males) " ) ] )
;;  
;;  output-print ( word " Number of aggressive behaviors: "
;;    ifelse-value ( anima1-to-inspect != nobody ) 
;;    [ [ length harm.history ] of subject ] 
;;    [ ( word sum [ length harm.history ] of anima1s with [ biological.sex = "female"] " (females) " sum [ length harm.history ] of anima1s with [ biological.sex = "male"] " (males) " ) ] )
;;  
;;  output-print ( word " Number of infanticides: "
;;    ifelse-value ( anima1-to-inspect != nobody ) 
;;    [ [ length infanticide.history ] of subject ] 
;;    [ ( word sum [ length infanticide.history ] of anima1s with [ biological.sex = "female"] " (females) " sum [ length infanticide.history ] of anima1s with [ biological.sex = "male"] " (males) " ) ] )
;;  
;;  output-print ( word " Number of copulations: "
;;    ifelse-value ( anima1-to-inspect != nobody ) 
;;    [ [ length copulations.history ] of subject ] 
;;    [ ( word sum [ length copulations.history ] of anima1s with [ biological.sex = "female"] " (females) " sum [ length copulations.history ] of anima1s with [ biological.sex = "male"] " (males) " ) ] )
;;  
;;  output-print ( word " Number of conceptions: "
;;    ifelse-value ( anima1-to-inspect != nobody ) 
;;    [ [ length conceptions.history ] of subject ] 
;;    [ ( word sum [ length conceptions.history ] of anima1s with [ biological.sex = "female"] " (females) " sum [ length conceptions.history ] of anima1s with [ biological.sex = "male"] " (males) " ) ] )
;;  
;;  output-print ( word " Number of group transfers: "
;;    ifelse-value ( anima1-to-inspect != nobody ) 
;;    [ [ length group.transfers.history ] of subject ] 
;;    [ ( word sum [ length group.transfers.history ] of anima1s with [ biological.sex = "female"] " (females) " sum [ length group.transfers.history ] of anima1s with [ biological.sex = "male"] " (males) " ) ] )
;;  
;;end
;;
;;;-----------------------------------------------------------------------------       
;;; VIEW STATUS
;;;-----------------------------------------------------------------------------   
;;
;;to output-status
;;  let anima1-to-inspect one-of anima1s with [ self = subject ]
;;  output-header (word " STATUS : " ifelse-value ( anima1-to-inspect = nobody ) [ "all individuals" ] [ (word "individual " [ meta.id ] of anima1-to-inspect ) ] )
;;  
;;  ;output-print ( word " Number of individuals: " count anima1z )
;;  output-print ( word " Number of females: " count anima1z with [ biological.sex = "female" ] )
;;  output-print ( word " Number of males: " count anima1z with [ biological.sex = "male" ] )
;;  
;;  let group-list []
;;  let group-size-list []
;;  let females-in-group []
;;  let males-in-group []
;;  let juveniles-in-group []
;;  let infants-in-group []
;;  let gestatees-in-group []
;;  
;;  ask anima1z [ if ( not member? group.identity group-list ) [ set group-list lput group.identity group-list ]]
;;  foreach group-list [ g -> 
;;    set group-size-list lput ( count anima1z with [ group.identity = g ] ) group-size-list 
;;    set females-in-group lput ( count anima1z with [ group.identity = g and biological.sex = "female" and life.history = "adult"] ) females-in-group 
;;    set males-in-group lput ( count anima1z with [ group.identity = g and biological.sex = "male" and life.history = "adult" ] ) males-in-group 
;;    set juveniles-in-group lput ( count anima1z with [ group.identity = g and life.history = "juvenile" ] ) juveniles-in-group
;;    set infants-in-group lput ( count anima1z with [ group.identity = g and life.history = "infant" ] ) infants-in-group
;;    set gestatees-in-group lput ( count anima1z with [ group.identity = g and life.history = "gestatee" ] ) gestatees-in-group
;;  ]
;;  
;;  output-print ( word " Number of groups: " length group-list )
;;  output-print ( word " Average group size: " precision mean group-size-list 2 )
;;  output-print ( word " Average number of adult females per group: " precision mean females-in-group 2 )
;;  output-print ( word " Average number of adult males per group: " precision mean males-in-group 2 )
;;  output-print ( word " Average number of juveniles per group: " precision mean juveniles-in-group 2 )
;;  output-print ( word " Average number of infants per group: " precision mean infants-in-group 2 )
;;  output-print ( word " Average number of gestatees per group: " precision mean gestatees-in-group 2 )
;;end
;
;
;
;
;
;
;
;
;
;
;






; save? - this one helps set a group to same color i think+
to-report get-group-identity-from-color [ color-of-group ]
  ifelse ( is-number? color-of-group ) [
    report ( random 999 * 140 + color-of-group )
  ][
    report "error: input value is not a number"
  ]
end


; save? - this one gives random chomrosome identities at first
to set-random-identity-chromosomes [ length-of-chromosomes ]
  let get-alphabet [ "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z" ]
  ifelse ( is-number? length-of-chromosomes ) [
    set identity.I ""
    set identity.II ""
    repeat length-of-chromosomes [ set identity.I (word identity.I one-of get-alphabet ) ]
    repeat length-of-chromosomes [ set identity.II (word identity.II one-of get-alphabet ) ]
  ][
    print "error: input value is not a number"
  ] 
end




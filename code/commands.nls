;-----------------------------------------------------------------------------
;                                                                dP          
;                                                                88          
; .d8888b. .d8888b. 88d8b.d8b. 88d8b.d8b. .d8888b. 88d888b. .d888b88 .d8888b. 
; 88'  `"" 88'  `88 88'`88'`88 88'`88'`88 88'  `88 88'  `88 88'  `88 Y8ooooo. 
; 88.  ... 88.  .88 88  88  88 88  88  88 88.  .88 88    88 88.  .88       88 
; `88888P' `88888P' dP  dP  dP dP  dP  dP `88888P8 dP    dP `88888P8 `88888P' 
;                                                                            
; © 2020 K N Crouse
;-----------------------------------------------------------------------------                                                                          

to command
  
  clear-output
  
  (ifelse 
    ( useful-commands = "help-me" ) [ output-command-menu ]
    ( useful-commands = "lotka-volterra" ) [ output-LV-plot ]
    ( useful-commands = "age-histogram" ) [ ]
    ( useful-commands = "metafile-report" ) [ output-metafile-report ]
    ( useful-commands = "verify-code" ) [ output-verification command-input ]
    ( useful-commands = "check-runtime" ) [ output-runtime ]  
    ( useful-commands = "simulation-report" ) [ output-simulation-report ]
    ( useful-commands = "genotype-reader" ) [ output-genotype-reader command-input ]
    ( useful-commands = "model-structure" ) [ output-model-structure command-input ]
    ( useful-commands = "import-world" ) [ ]
    ( useful-commands = "clear-plants" ) [ output-clear-plants ]
    ( useful-commands = "setup-plants" ) [ output-setup-plants ]
    ( useful-commands = "clear-population" ) [ output-clear-pop ]
    ( useful-commands = "view-genotype" ) [ output-genotype ]
    ( useful-commands = "view-decisions" ) [ output-decisions ]
    ( useful-commands = "view-allocation" ) [ output-allocation ]
    ( useful-commands = "view-actions") [ output-actions ]
    ( useful-commands = "add-allele" ) [ output-add-allele ]
    ( useful-commands = "delete-allele" ) [ output-delete-allele command-input ]
    ( useful-commands = "population-report") [ output-population ]
    [])

end

to output-genotype-reader [ input ]
  let genotype-list [ "sta7us" "g8tes" ]
  ifelse ( member? input genotype-list ) [
    ifelse ( genotype-reader = input ) [
      set command-input one-of remove input genotype-list
    ][
      set genotype-reader input
    ]
  ][
    set command-input one-of genotype-list
  ]
end

to output-model-structure [ input ]
  let structure-list [ "no-plants" "reaper" "sower" "aspatial" "free-lunch" "no-evolution" "ideal-form" "uninvadable" ]
  ifelse ( member? input structure-list ) [
    ifelse ( model-structure = input ) [
      set command-input one-of remove input structure-list
    ][
      set model-structure input
    ]
  ][
    set command-input one-of structure-list
  ]
end

to output-command-menu
  
  output-header " HELP ME: a user guide for commands"
  output-print " Select a command option from the useful-commands dropdown menu and"
  output-print " click ▷ to enact the command. A description of each command is listed below." 
  output-print " Commands that are denoted below by [ ] require an input to be written"
  output-print " in command-input. By default, command-input contains an example allele"
  output-print " for the add-allele and delete-allele commands."
  output-print ""
  output-print " > PLOTS"
  output-print ""
  output-print "  lotka-volterra : plots organism (brown)-plant (green) population dynamics"
  output-print "  age-histogram : plots age histogram binned into years"
  output-print ""
  output-print " > SIMULATION"
  output-print ""
  output-print "  metafile-report : prints a summary of user activities"
  output-print "  verify-code : prints a summary of verification code checks"
  output-print "  check-runtime : prints a summary of simulation operations"    
  output-print "  simulation-report : prints a summary of current simulation"
  output-print "  genotype-reader : set the genotype file format of simulation"
  output-print "  model-structure : set the model structure for the simulation"
  output-print ""
  output-print " > WORLD"
  output-print ""
  ;    output-print "  export-world [ filename ] : saves the current simulation world to filename"
  ;    output-print "  import-world [ filename ] : import previous simulation world from filename"
  output-print "  clear-plants : clears all vegetation from the world"
  output-print "  setup-plants : replenishes the world with plants"
  output-print ""
  output-print " > ORGANISMS"
  output-print ""
  output-print "  clear-population: removes all organisms from the world"
  output-print "  view-genotype [ meta-id ] : prints the genotype of an organism"
  output-print "  view-decisions [ meta-id ] : shows the current decisions of an organism"
  output-print "  add-allele [ code ] : add mutation to population"
  output-print "  delete-allele [ code ] : delete allele from everywhere in the population"
  output-print "  population-report : prints a summary of current population"
  output-print ""
  
end

to output-header [ header-title ]
  clear-output
  output-print " ---------------------------------------------------------------------------"
  output-print ( word " " header-title )
  output-print " ---------------------------------------------------------------------------"
  update-metafile "commands" header-title 
end

to output-LV-plot
  clear-plot
  let plts ( plant-quality * count plants / 100 )
  let anls count anima1s
  let max-value max (list plts anls )
  set-plot-x-range 0 10
  set-plot-y-range 0 ( max-value + 10 )
  
end

to output-metafile-report
  output-header (word "METAFILE :"  date-and-time " " documentation-notes )
  ;    let i 0

  ;    foreach reverse but-first csv:from-file "../data/metafile.csv" [ x -> 
  ;      if ( i < 25 ) [ output-print (word " " item 0 x "  " item 7 x  ) ]
  ;      set i i + 1
  ;    ]
  ;    set documentation-notes (word "Printout metafile report. " documentation-notes )
end

to output-verification [ input ]

  if (useful-commands = "verify-code" and not is-boolean? read-from-string command-input ) [
    output-print " ---------------------------------------------------------------------------"
    output-print " CODE VERIFICATION :    "
    output-print " ---------------------------------------------------------------------------"
    let new-tape generate-verification-tape
    let length-of-tape length first new-tape
    let i 0
    
    while [ i < length-of-tape ]
    [
      (ifelse 
        ( i < 4 ) [output-print (word " "  item i item 0 new-tape " " item i item 3 new-tape ) if ( i = 3 ) [ output-print ( "     " ) ] ]
        [ output-print (word " " (i - 3) ". " item i item 3 new-tape "  " item i item 2 new-tape "  " item i item 1 new-tape "  :  " item i item 0 new-tape )])
      set i i + 1
    ]
    set documentation-notes (word "Printout code verification. " documentation-notes )
  ]
  
  if (useful-commands = "verify-code" and read-from-string command-input = true ) [
    output-print " ---------------------------------------------------------------------------"
    output-print " CODE VERIFICATION : TRUE only   "
    output-print " ---------------------------------------------------------------------------"
    let new-tape generate-verification-tape
    let length-of-tape length first new-tape
    let i 0
    let j 0
    while [ i < length-of-tape ]
    [
      (ifelse 
        ( i < 4 ) [output-print (word " "  item i item 0 new-tape " " item i item 3 new-tape ) if ( i = 3 ) [ output-print ( "     " ) ] ]
        [ if (item i item 3 new-tape = true ) [ set j j + 1 output-print (word " " j ". " item i item 3 new-tape " " item i item 2 new-tape " " item i item 1 new-tape " : " item i item 0 new-tape ) ]])
      set i i + 1
    ]
    set documentation-notes (word "Printout code verification, TRUE only. " documentation-notes )
  ]
  
  if (useful-commands = "verify-code" and read-from-string command-input = false ) [
    output-print " ---------------------------------------------------------------------------"
    output-print " CODE VERIFICATION : FALSE only   "
    output-print " ---------------------------------------------------------------------------"
    clear-output
    let new-tape generate-verification-tape
    let length-of-tape length first new-tape
    let i 0
    let j 0
    while [ i < length-of-tape ]
    [
      (ifelse 
        ( i < 4 ) [output-print (word " " item i item 0 new-tape " " item i item 3 new-tape ) if ( i = 3 ) [ output-print ( "     " ) ] ]
        [ if (item i item 3 new-tape = false) [ set j j + 1 output-print (word " " j ". " item i item 3 new-tape " " item i item 2 new-tape " " item i item 1 new-tape " : " item i item 0 new-tape ) ]])
      set i i + 1
    ]
    set documentation-notes (word "Printout code verification, FALSE only. " documentation-notes )
  ]
end

to output-runtime
    output-header "CHECK RUNTIME :   "
    profiler:reset
    profiler:start
    repeat how-many-ticks? [ go ]
    output-print profiler:report 
    profiler:stop
    set documentation-notes (word "Printout runtime check." documentation-notes )  
end

to output-simulation-report
  output-header (word " SIMULATION REPORT : " simulation-id )
  output-print ( word "  simulation-id:  " simulation-id )
  output-print ( word "  model-version:  " model-version )
  output-print ( word "  model-structure:  " model-structure )
  output-print ( word "  genotype-reader:  " genotype-reader )
end

to output-simulation-file
  output-header (word " SIMULATION FILE : " simulation-id )

  ifelse (file-exists? (word path-to-experiment "/" simulation-id ".csv" ) ) [
    let header-list first csv:from-file (word path-to-experiment "/" simulation-id ".csv" )
    
    output-print " ticks plants organisms generations sex-ratio gesties infants juvies adults "
    
    let i 0
    foreach reverse but-first csv:from-file (word path-to-experiment "/" simulation-id ".csv" ) [ x -> 
      if ( i < 25 ) [ output-print (word "  " item 14 x  "   " precision item 23 x 0 "    " item 24 x "       " ifelse-value ( item 25 x = 0 ) [ 0.001 ] [ item 25 x ]  "       " precision ( item 26 x / item 27 x ) 2 "      " item 28 x "       " item 29 x "      " item 30 x "      " item 31 x  ) ]
      set i i + 1
    ]
    set documentation-notes (word "Printout simulation report. " documentation-notes )
  ][
    set documentation-notes (word "Simulation file not found. " documentation-notes )
    output-print "Simulation file not found."
    output-print "Please check 'data' extension settings."
  ]
end

to import-world-command
  ;    let old-path-to-experiment path-to-experiment
  ;    let old-command-input command-input
  ;    import-world ( word old-path-to-experiment "/" old-command-input ".csv" )
  ;    set path-to-experiment old-path-to-experiment
  ;    ask anima1s [ set generation-number 0 ]
  ;    reset-ticks
  ;    set simulation-id 0
  ;    update-simulation
  ;    set useful-commands "import-world"
  ;    set documentation-notes (word "Import world " old-command-input "." documentation-notes ) 
end

to output-clear-plants
  output-header " CLEAR PLANTS :   "
  ask plants [ die ]
  output-print " Plants cleared."
  set documentation-notes (word "Clear all plants in simulation. " documentation-notes )
end

to output-setup-plants
  output-header " SETUP PLANTS :   "
  setup-plants
  output-print " Let there be plants!"
  set documentation-notes (word "Setup new plants in simulation. " documentation-notes )  
end

to output-clear-pop
  output-header " CLEAR POPULATION :   "
  ask anima1s [ die ]
  ask groups [ die ]
  output-print " Population cleared."
  set documentation-notes (word "Clear current population. " documentation-notes )
end

to output-genotype
  let anima1-to-inspect one-of anima1s with [ read-from-string command-input = meta-id ]
  output-header (word " GENOTYPE : " ifelse-value ( anima1-to-inspect = nobody ) [ "" ] [ (word "organism " [meta-id] of anima1-to-inspect ) ] )
  ifelse ( anima1-to-inspect = nobody ) [
    set documentation-notes (word "Organism " read-from-string command-input " not found.")
    output-print (word " Organism " read-from-string command-input " not found.")
  ][
    foreach [chromosome.I] of anima1-to-inspect [ a ->
      output-print (word " "reduce [ [itm nxt] -> (word itm " " nxt ) ] a ) ]
    output-print ""
    foreach [chromosome.II] of anima1-to-inspect [ a ->
      output-print (word " "reduce [ [itm nxt] -> (word itm " " nxt ) ] a ) ]
    set documentation-notes (word "View genotype of organism " command-input ". " documentation-notes )
  ]
end

to output-decisions
  let anima1-to-inspect one-of anima1s with [ read-from-string command-input = meta-id ]
  output-header (word " DECISIONS : " ifelse-value ( anima1-to-inspect = nobody ) [ "" ] [ (word "organism " [meta-id] of anima1-to-inspect ) ] )

  ifelse ( any? anima1s with [ meta-id = read-from-string command-input ] ) [
    ask one-of anima1s with [ meta-id = read-from-string command-input ] [
      foreach decision.vectors [ decision ->
        output-print (word " " decision )
      ]
    ]
    set documentation-notes (word "View current decisions of organism " command-input ". " documentation-notes )
  ][
    set documentation-notes (word "Organism " read-from-string command-input " not found.")
    output-print (word " Organism " read-from-string command-input " not found.")
  ]
end

to output-allocation
  let anima1-to-inspect one-of anima1s with [ read-from-string command-input = meta-id ]
  output-header (word " ENERGY : " ifelse-value ( anima1-to-inspect = nobody ) [ "" ] [ (word "organism " [meta-id] of anima1-to-inspect ) ] )
  
  ifelse ( any? anima1s with [ meta-id = read-from-string command-input ] ) [
    ask one-of anima1s with [ meta-id = read-from-string command-input ] [
      foreach energy.allocated [ decision ->
        output-print (word " " decision )
      ]
    ]
    set documentation-notes (word "View current decisions of organism " command-input ". " documentation-notes )
  ][
    set documentation-notes (word "Organism " read-from-string command-input " not found.")
    output-print (word " Organism " read-from-string command-input " not found.")
  ]
end

to output-actions
  let anima1-to-inspect one-of anima1s with [ read-from-string command-input = meta-id ]
  output-header (word " ACTIONS : " ifelse-value ( anima1-to-inspect = nobody ) [ "" ] [ (word "organism " [meta-id] of anima1-to-inspect ) ] )
  
  ifelse ( any? anima1s with [ meta-id = read-from-string command-input ] ) [
    ask one-of anima1s with [ meta-id = read-from-string command-input ] [
      foreach completed.actions [ decision ->
        output-print (word " " decision )
      ]
    ]
    set documentation-notes (word "View current decisions of organism " command-input ". " documentation-notes )
  ][
    set documentation-notes (word "Organism " read-from-string command-input " not found.")
    output-print (word " Organism " read-from-string command-input " not found.")
  ]
end

to output-add-allele
  output-header (word " ADD NEW ALLELE : " )

  ifelse ( is-list? read-from-string command-input and length read-from-string command-input > 4 ) [
    ask anima1s [
      set chromosome.I lput run-result command-input chromosome.I
      set chromosome.II lput run-result command-input chromosome.II
    ]
    set documentation-notes (word "Add mutation " command-input " to the population. " documentation-notes ) 
    output-print (word " Allele " command-input " was successfully added." )
  ][
    set documentation-notes (word "Adding allele " command-input " was unsuccessful." )
    output-print (word " Adding allele " command-input " was unsuccessful." )
    output-print " Alleles should have the following structure:"
    output-print ""
    output-print " [ true am cf MAT 0.009 ]"
  ]
end

to output-delete-allele [ input ]
  output-header (word " DELETE ALLELE : " )
  
  ifelse ( is-list? read-from-string input ) [
    ask anima1s [
      foreach chromosome.I [ i ->
        if ( i = read-from-string command-input ) [
          set chromosome.I remove-item ( position i chromosome.I ) chromosome.I ]]
      foreach chromosome.II [ ii ->
        if ( ii = read-from-string command-input ) [
          set chromosome.II remove-item ( position ii chromosome.II ) chromosome.II ]]]
    
    set documentation-notes (word "Delete allele " read-from-string  command-input " from the population. " documentation-notes ) 
    output-print (word " Allele " read-from-string command-input " successfully deleted." )]
  
  [ output-print (word " Command input is not a list." )]
  
end

to output-population
  output-header ( word "POPULATION REPORT : " simulation-id )
  output-print (word " population size: " count anima1s )
  output-print (word " number of males: " count anima1s with [ biological.sex = "male" ] )
  output-print (word " number of females: " count anima1s with [ biological.sex = "female" ] )
end


